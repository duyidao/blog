# 前端性能优化方案

## 资源加载优化

首屏速度是用户体验最关键的一环，资源加载速度是影响性最大的因素。资源的加载速度 = 资源大小 + 网速。资源大小影响的方面有：

1. 压缩
2. 一部分代码分割出来做异步加载，需要使用的时候再加载出来
3. 代码尽量精简

### prefetch加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i145fP.png](https://i.imgloc.com/2023/05/07/i145fP.png)

无论是同步还是异步都会先创建一个 `link` 标签去加载，只不过异步的page3会标记 `prefetch` ，没有该标记则说明是需要先加载的，同步加载的资源都加载完毕后再去加载异步加载的资源。

异步加载一般都是使用 `import` 方法来引入使用，例如：

- 组件

  ```js
  components: {
      HelloWord: import('../about/xx.vue')
  }
  ```

- 路由

  ```js
  {
      path: 'about',
      component: () => import('@/views/about')
  }
  ```

**排查方式**

前往开发者 `network` 修改网络为高速3G，刷新页面可以发现，`about` 资源状态处于 `padding` 等待状态，直到同步资源加载完毕才加载。

查看源代码，其引入代码有一个 `typ="prefetch"` 的标识。

### script加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i14YGz.png](https://i.imgloc.com/2023/05/07/i14YGz.png)

如果是异步状态它不会去加载，等到用户要跳转到 page3 它才会去加载。

`script` 加载方式需要前往 `vue.config.js` 文件修改，代码示例如下：

```js
module.exports = {
    chainWebpack: config => {
        config.plugins.delete('prefetch')
    }
}
```

如果在关闭 `prefetch` 的情况下想要部分路由使用 `prefetch` 加载，可以为其添加注释，代码示例：

```js
{
    path: 'about',
    component: () => import(/*webpackPrefetch:true*/ '@/views/about')
}
```

> 这个是 `webpack` 提供的功能，与 `vue` 无关，如果你是使用 `webpack` 创建的 `react` 项目也需要这么配置。

如果需要开启 `prefetch` 则在 `webpackPrefetch` 方法后添加 `true` （没有 `false` 这个选项）。或者填入数字，表示优先级。数字越大优先级越高，会优先加载（`true` 视为0）。

### 总结

- script：
  1. 做到了真正的按需引入，用到的时候再加载，不用永不加载，充分减小带宽
  2. 最大的问题在于，切换需要等待，体验感不是很流畅
- prefetch
  1. 充分利用使用者不占用带宽的浏览时间，切换到异步加载的页面是可能已经加载好了，用户体验好
  2. 一些本次行为不会打开的页面也会加载，一定程度上浪费带宽

### 优化经验

#### 使用按需引入（函数式）的版本

如 `xlsx` 第三方库，有很多方法，我们只用了其中几个方法，但是全部引入他会都打包，项目体积会变大。

```js
import xlsx from 'xlsx'
```

因此可以使用按需引入的方法。方法为：

- 卸载依赖重新安装。目的是安装最新版本，实现按需引入。老版本的库可能不支持该方法）
- 采用解构的方式引入我们需要的方法即可

```js
import {read, utils} from 'xlsx'
```

#### 在组件 mounted 阶段再引入库，或者用到这个功能时再引入

有部分功能与页面展示没太大关系，可能功能也不是第一时间使用，因此可以写在函数内，在 `mounted` 阶段引入。

```vue
<script>
    let $;
    
    export default {
    	 mounted() {
		    this.changeTest()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    }
		}
    }
</script>
```

`jquery` 源码是通过 `export default` 导出，因此 `res.default` 才是 `jquery` 方法。`import` 异步引入返回一个 `Promise` ，可以使用 `.then` 获取回调参数。

在外层定义全部变量赋值。

前面的 `xlsx` 也可以使用该方法异步引入，示例代码如下：

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import('xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

#### 利用 prefetch 调控加载顺序

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import(/*webpackPrefetch:10*/'jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import(/*webpackPrefetch:1*/'xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

## 图片懒加载

当一个网站图片数量太多，会造成很大的性能消耗。而有时候页面还没拉到下面，且用户有可能不浏览下面的数据，此时那些图片加载的性能消耗就被浪费掉了。

图片懒加载的实现原理就是在用户页面滑动到该图片的位置时再去加载图片。要想实现该功能，需要了解如下的前置知识。

### 前置知识

#### 自定义指令

在 `vue2` 中，自定义指令的创建方式为通过 `directives` 关键字设置自定义指令，其中分为全局注册和局部注册：

- 局部注册

  ```vue
  <template>
  <div id="home">
       <input type="text" v-focus="daodao">
  </div>
  </template>
  <script>
  export default{
      name:"home",
      directives:{
          focus:{
              //参数一：当前元素，参数二：绑定的一些相关信息，参数三:虚拟dom节点，参数四：上一个虚拟dom
              bind(el,binding,vNode,oldvNode){
                  el.focus(); // 元素获焦
                  el.value = binding.value // 把值赋值上去
              }
          }
      },
  }
  </script> 
  ```

- 全局注册

  ```js
  //注册全局指令
  Vue.directive('demo', {
    //自定义指令钩子函数
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus()
    }
  })
  ```

  第二个参数是一个对象，里面包含每个生命周期钩子函数。如果只关心 `bind` 和 `update` 时触发相同行为，而不关心其它的钩子。可以这样写：

  ```js
  Vue.directive('color-swatch', function (el, binding) {
    el.style.backgroundColor = binding.value
  })
  ```

在 `vue3` 中，自定义指令需要这样写：

- 局部注册

  ```vue
  <script setup>
  // 在模板中启用 v-focus
  const vFocus = {
    mounted: (el) => el.focus()
  }
  </script>
  
  <template>
    <input v-focus />
  </template>
  ```

- 全局注册

  ```js
  const app = createApp({})
  
  // 使 v-focus 在所有组件中都可用
  app.directive('focus', {
    /* ... */
  })
  ```

  同样的，`vue3` 自定义指令的参数二也支持简写形式，如果是仅仅需要在 `mounted` 和 `updated` 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：

  ```html
  <div v-color="color"></div>
  ```

  ```js
  app.directive('color', (el, binding) => {
    // 这会在 `mounted` 和 `updated` 时都调用
    el.style.color = binding.value
  })
  ```

#### 页面元素可视

MDN 这么描述 [IntersectionObserver()](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) 方法：

> **`IntersectionObserver`** 接口（从属于 [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)）提供了一种异步观察目标元素与其祖先元素或顶级文档[视口](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)（viewport）交叉状态的方法。其祖先元素或视口被称为根（root）。
>
> 当一个 `IntersectionObserver` 对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦 `IntersectionObserver` 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。

翻译成大白话来说就是，它可以判断元素是否出现在可视区域中的方法。其中它的参数中 `intersectionRatio` 属性小于等于0则代表它还未出现在可视区域内。

### 代码实现

实现步骤如下：

1. 为图片绑定一个自定义指令，把是否需要懒加载的参数传过去。再通过自定义属性 `data-` 保存该图片的路径
2. 在元素挂载到页面上的钩子函数中判断该图片是否需要懒加载
   - 不需要懒加载，直接获取图片路径并赋值渲染
   - 需要懒加载，把本地保存的占位图片路径赋值过去
3. 通过 `new IntersectionObserver()` 方法中的 `observe()` 判断当前图片节点是否在可视区域，在可视区域内再获取图片的自定义属性并赋值
4. 通过 `unobserve()` 取消监听图片节点

```vue
<template>
  <div class="box">
    <div class="wrapper">
      <img v-lazy="{ nolazy }" :data-src="src" v-bind="$attrs" class="image" />
    </div>
  </div>
</template>

<script>
function lazyBinding(el, binding) {
  const placehold = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'

  const { nolazy } = binding.value

  if (nolazy) return (el.src = el.dataset.src || placehold)

  el.src = placehold

  const obServer = new IntersectionObserver(entries => {
    // 如果 intersectionRatio 为 0，则目标在视野外，
    // 我们不需要做任何事情。
    if (entries.find(v => v.intersectionRatio)) {
      el.src = el.dataset.src || placehold
      obServer.unobserve(el)
    }
  })
  obServer.observe(el)
}

export default {
  inheritAttrs: false,
  props: {
    lazy: {
      type: Boolean,
      default: true,
    },
    src: {
      type: String,
      default: '',
    },
  },
  computed: {
    nolazy() {
      return !this.lazy
    },
  },
  directives: {
    lazy: {
      bind(el, binding) {
        lazyBinding(el, binding)
      },
      componentUpdated(el, binding) {
        lazyBinding(el, binding)
      },
    },
  },
}
</script>

<style scoped lang="scss">
@keyframes fade {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  background-color: rgb(168, 210, 255);
  &.show {
    animation: fade 0.5s ease-in-out;
  }
}
</style>
```

封装成一个子组件，方便后续父组件复用。

## 打包优化

项目的构建速度由两个方面决定：

- 处理的内容数量
- 进行的操作

优化操作一般有以下几点：

1. 减少处理内容数量

   指定 `include` 和 `exclude` 排除掉一些不必要的处理； DLL 优化处理

2. 提高处理效率

   多线程操作；缓存 `sourcemap` 

3. 减少操作的数量

   去掉一些没意义的操作

### 减少处理内容数量

#### 排除不必要的处理

先来看看一段 `vue.config.js` 代码：

```js
const path = require('path')
function resolve(dir) {
    return path.join(__dirname, dir)
}

module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? './' : '/',
    chainWebpack: (config) => {
        config.resolve.alias.set('@', resolve('src'))
    },
    productionSourceMap: false,
    devServer: {
        open: false,
        port: 5003,
        overlay: {
            errors:true,
            warmimgs: true,
        },
        proxy: {
            '/api': {
                target: 'xxx',
                changeOrigin: true
            }
        }
    }
}
```

打包这个项目，打包的时间为 6.4s，接下来测试一下通过 `exclude` 排除后能减少多少时间。

需要注意的是，不能什么都能排除， `js` 文件 `webpack` 本来就认识，但是 `ts` 、`vue` 、`html` 等文件不能排除，需要处理，通过 `babel-loader-es6-es5` 转编译。

开发环境中排除掉 `js` 中的 `node_modules` 和 `src` ，代码如下：

```js
const path = require('path')
function resolve(dir) {
    return path.join(__dirname, dir)
}

module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? './' : '/',
    chainWebpack: (config) => {
        if(config.module.rule('js').exclude
          .add(resolve('/node_modules'))
          .add(resolve('/src'))
        )
        config.resolve.alias.set('@', resolve('src'))
    },
    // ...
}
```

重新打包，打包时间缩短为 6.19s，这个项目用到的 `js` 不多，如果 `js` 文件多的话能减少更多的时间。

#### DLL处理

接下来做 DLL 处理，步骤为先把一些第三方库打包，后续打包时候不去打包这些第三方库，而是直接复用。

根目录下新建一个 `webpack.dll.js` 文件，代码如下：

```js
const path = require('path')
const webpack = require('webpack')

// dll 文件存放的目录
const dllPath = 'public/vendor'
module.exports = {
    mode: 'production',
    entry: {
        // 需要提取的库文件
        vendor: ['vue', 'vuex', 'vue-router', 'element-ui', 'echarts']
    },
    // 定义出口
    output: {
        // 当前目录下的 public文件夹下的 vendor 
        path: path.join(__dirname, dllPath),
        filename: '[name].dll.js',
        // vendor.dll.js 中暴露出的全局变量名
        // 保持与 webpack.DllPlugin 中名称一致
        library: '[name]_[hash]'
    },
    plugins: [
        // manifest.json 描述动态链接库包含了哪些内容
        new webpack DllPlugin({
        	path: path.join(__dirname, dllPath, '[name]-manifest.json'),
    		// 保持与 output.library 中名称一致
    		name: '[name]_[hash]',
    		context:process.cwd()
        })
    ]
}
```

接着去到 `package.json` 文件重写打包命令：

```json
{
    // ...
    "scripts": {
        "dll": "webpack --config webpack.dll.js",
        // ...
    }
}
```

通过新命令打包，会遇到一个坑，它会提示你是否要下载 `wenpack-cli` ，如果直接点 yes ，会有版本冲突问题，正确做法是先在全局下载 `webpack-cli` ：

```
npm i webpack-cli@3.3.12 --save-dev
```

然后再运行命令：

```
npm run dll
```

运行完毕， `public` 文件夹下已经有打包好的 `vendor` 文件夹，接下来回到 `vue.config.js` 文件，添加 `webpack` 配置，代码如下：

```js
const path = require('path')
const webpack = require('webpack')
function resolve(dir) {
    return path.join(__dirname, dir)
}

module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? './' : '/',
    configureWebpack: {
        plugins: [
            new webpack.DllReferencePlugin({
                context: process.cwd(),
                // 关键设置，引用的文件地址
                manifest: require('./public/vendor/vendor-manifest.json')
            })
        ]
    },
    // ...
}
```

改完配置文件后因为没有缓存了，所以第一次打包速度会比较慢，以后续打包时间为准。打包后发现时间已经缩短为 3.15s 。

不过现在还没结束，打包完毕后此时项目如果在浏览器上打开，页面一片空白。这是因为前面打包的时候把这些资源排除掉不打包了，解决方法为去到 `index.html` 文件中，把那些排除出去的 `js` 文件手动引入。

```html
<script src="<%= BASE_URL %>vendor/vendor.dll.js"></script>
```

### 提高处理效率

#### 多线程处理

多线程打包的收益在项目较小的时候其实不是很明显，因为开启多线程也需要额外的操作。

想要使用多线程需要下载一个 `loader` ：

```
npm i thread-loader --save
```

下载同时来写代码，在 `vue.config.js` 文件中引入使用：

```js
const os = require('os')
const path = require('path')
function resolve(dir) {
    return path.join(__dirname, dir)
}

module.exports = {
    chainWebpack: (config) => {
        if(config.module.rule('js').exclude
          	.add(resolve('/node_modules'))
          	.add(resolve('/src'))
           config.module.rule('vue').use('thread-loader')
            .loader('thread-loader').tap(() =>{
            	return {
                	// 根据当前cpu数量
                	worker: os.cpus().length
            	}
        	}).before('vue-loader') // 在vue-loader处理完后再处理
        )
        config.resolve.alias.set('@', resolve('src'))
    },
    // ...
}
```

但是这样可能不会生效，甚至会有反效果，这是因为优化之后也有可能会增多处理。

上方开多线程这个举动也是需要时间，多线程处理的时间比开启多线程的时间要少，因此最后打包时间也会增多，不太推荐使用该方法。

#### sourceMap

举个例子，我在 `login.vue` 页面 `console.log()` 输出一行代码，开启 `sourceMap` 后可以根据这个输出定位到是哪个文件哪行代码输出的。在生产模式时没必要打开。

Vue-cli 中配置的默认 `eval` 的 `sourceMap` ，可以关闭，代码如下：

```js
module.exports = {
    configureWebpack: {
        devtool: 'none',
        plugins: [
            // ...
        ]
    },
}
```

关闭之后打包时间确实有减少，但是打开项目之后查看控制台的打印，会定位到打包好的文件，不利于我们排错，因此不推荐关闭。

> 注意
>
> CSS 的 `sourceMap` 默认是关闭的，可以打开，但是最后打包时间会增加，因为增加了要处理的内容。开启方式为在 `vue.config.js` 文件设置以下代码：
>
> ```js
> module.exports = {
>     // ...
>     css: {
>         sourceMap: true
>     }
> }
> ```

### 完整代码

`vue.config.js` 完整代码如下：

```js
const os = require('os')
const path = require('path')
function resolve(dir) {
    return path.join(__dirname, dir)
}

module.exports = {
    publicPath: process.env.NODE_ENV === 'production' ? './' : '/',
    chainWebpack: (config) => {
        if(config.module.rule('js').exclude
          	.add(resolve('/node_modules'))
          	.add(resolve('/src'))
           
           /** 
           * 多线程处理模块start，不太推荐使用
           */
           config.module.rule('vue').use('thread-loader')
            .loader('thread-loader').tap(() =>{
            	return {
                	// 根据当前cpu数量
                	worker: os.cpus().length
            	}
        	}).before('vue-loader') // 在vue-loader处理完后再处理
           /** 
           * 多线程处理模块end
           */
        )
        config.resolve.alias.set('@', resolve('src'))
    },
    configureWebpack: {
        plugins: [
            new webpack.DllReferencePlugin({
                context: process.cwd(),
                // 关键设置，引用的文件地址
                manifest: require('./public/vendor/vendor-manifest.json')
            })
        ]
    },
    productionSourceMap: false,
    devServer: {
        open: false,
        port: 5003,
        overlay: {
            errors:true,
            warmimgs: true,
        },
        proxy: {
            '/api': {
                target: 'xxx',
                changeOrigin: true
            }
        }
    }
}
```

## 未完待续......

