# 前端性能优化方案

## 资源加载优化

首屏速度是用户体验最关键的一环，资源加载速度是影响性最大的因素。资源的加载速度 = 资源大小 + 网速。资源大小影响的方面有：

1. 压缩
2. 一部分代码分割出来做异步加载，需要使用的时候再加载出来
3. 代码尽量精简

### 加载方式

#### prefetch加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i145fP.png](https://i.imgloc.com/2023/05/07/i145fP.png)

无论是同步还是异步都会先创建一个 `link` 标签去加载，只不过异步的page3会标记 `prefetch` ，没有该标记则说明是需要先加载的，同步加载的资源都加载完毕后再去加载异步加载的资源。

异步加载一般都是使用 `import` 方法来引入使用，例如：

- 组件

  ```js
  components: {
      HelloWord: import('../about/xx.vue')
  }
  ```

- 路由

  ```js
  {
      path: 'about',
      component: () => import('@/views/about')
  }
  ```

**排查方式**

前往开发者 `network` 修改网络为高速3G，刷新页面可以发现，`about` 资源状态处于 `padding` 等待状态，直到同步资源加载完毕才加载。

查看源代码，其引入代码有一个 `typ="prefetch"` 的标识。

#### script加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i14YGz.png](https://i.imgloc.com/2023/05/07/i14YGz.png)

如果是异步状态它不会去加载，等到用户要跳转到 page3 它才会去加载。

`script` 加载方式需要前往 `vue.config.js` 文件修改，代码示例如下：

```js
module.exports = {
    chainWebpack: config => {
        config.plugins.delete('prefetch')
    }
}
```

如果在关闭 `prefetch` 的情况下想要部分路由使用 `prefetch` 加载，可以为其添加注释，代码示例：

```js
{
    path: 'about',
    component: () => import(/*webpackPrefetch:true*/ '@/views/about')
}
```

> 这个是 `webpack` 提供的功能，与 `vue` 无关，如果你是使用 `webpack` 创建的 `react` 项目也需要这么配置。

如果需要开启 `prefetch` 则在 `webpackPrefetch` 方法后添加 `true` （没有 `false` 这个选项）。或者填入数字，表示优先级。数字越大优先级越高，会优先加载（`true` 视为0）。

#### 总结

- script：
  1. 做到了真正的按需引入，用到的时候再加载，不用永不加载，充分减小带宽
  2. 最大的问题在于，切换需要等待，体验感不是很流畅
- prefetch
  1. 充分利用使用者不占用带宽的浏览时间，切换到异步加载的页面是可能已经加载好了，用户体验好
  2. 一些本次行为不会打开的页面也会加载，一定程度上浪费带宽

#### 优化经验

##### 使用按需引入（函数式）的版本

如 `xlsx` 第三方库，有很多方法，我们只用了其中几个方法，但是全部引入他会都打包，项目体积会变大。

```js
import xlsx from 'xlsx'
```

因此可以使用按需引入的方法。方法为：

- 卸载依赖重新安装。目的是安装最新版本，实现按需引入。老版本的库可能不支持该方法）
- 采用解构的方式引入我们需要的方法即可

```js
import {read, utils} from 'xlsx'
```

##### 在组件 `mounted` 阶段再引入库，或者用到这个功能时再引入

有部分功能与页面展示没太大关系，可能功能也不是第一时间使用，因此可以写在函数内，在 `mounted` 阶段引入。

```vue
<script>
    let $;
    
    export default {
    	 mounted() {
		    this.changeTest()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    }
		}
    }
</script>
```

`jquery` 源码是通过 `export default` 导出，因此 `res.default` 才是 `jquery` 方法。`import` 异步引入返回一个 `Promise` ，可以使用 `.then` 获取回调参数。

在外层定义全部变量赋值。

前面的 `xlsx` 也可以使用该方法异步引入，示例代码如下：

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import('xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

##### 利用prefetch调控加载顺序

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import(/*webpackPrefetch:10*/'jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import(/*webpackPrefetch:1*/'xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

## 图片懒加载

当一个网站图片数量太多，会造成很大的性能消耗。而有时候页面还没拉到下面，且用户有可能不浏览下面的数据，此时那些图片加载的性能消耗就被浪费掉了。

图片懒加载的实现原理就是在用户页面滑动到该图片的位置时再去加载图片。要想实现该功能，需要了解如下的前置知识。

### 前置知识

#### 自定义指令

在 `vue2` 中，自定义指令的创建方式为通过 `directives` 关键字设置自定义指令，其中分为全局注册和局部注册：

- 局部注册

  ```vue
  <template>
  <div id="home">
       <input type="text" v-focus="daodao">
  </div>
  </template>
  <script>
  export default{
      name:"home",
      directives:{
          focus:{
              //参数一：当前元素，参数二：绑定的一些相关信息，参数三:虚拟dom节点，参数四：上一个虚拟dom
              bind(el,binding,vNode,oldvNode){
                  el.focus(); // 元素获焦
                  el.value = binding.value // 把值赋值上去
              }
          }
      },
  }
  </script> 
  ```

- 全局注册

  ```js
  //注册全局指令
  Vue.directive('demo', {
    //自定义指令钩子函数
    // 当被绑定的元素插入到 DOM 中时……
    inserted: function (el) {
      // 聚焦元素
      el.focus()
    }
  })
  ```

  第二个参数是一个对象，里面包含每个生命周期钩子函数。如果只关心 `bind` 和 `update` 时触发相同行为，而不关心其它的钩子。可以这样写：

  ```js
  Vue.directive('color-swatch', function (el, binding) {
    el.style.backgroundColor = binding.value
  })
  ```

在 `vue3` 中，自定义指令需要这样写：

- 局部注册

  ```vue
  <script setup>
  // 在模板中启用 v-focus
  const vFocus = {
    mounted: (el) => el.focus()
  }
  </script>
  
  <template>
    <input v-focus />
  </template>
  ```

- 全局注册

  ```js
  const app = createApp({})
  
  // 使 v-focus 在所有组件中都可用
  app.directive('focus', {
    /* ... */
  })
  ```

  同样的，`vue3` 自定义指令的参数二也支持简写形式，如果是仅仅需要在 `mounted` 和 `updated` 上实现相同的行为，除此之外并不需要其他钩子。这种情况下我们可以直接用一个函数来定义指令，如下所示：

  ```html
  <div v-color="color"></div>
  ```

  ```js
  app.directive('color', (el, binding) => {
    // 这会在 `mounted` 和 `updated` 时都调用
    el.style.color = binding.value
  })
  ```

#### 页面元素可视

MDN 这么描述 [IntersectionObserver()](https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver) 方法：

> **`IntersectionObserver`** 接口（从属于 [Intersection Observer API](https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API)）提供了一种异步观察目标元素与其祖先元素或顶级文档[视口](https://developer.mozilla.org/zh-CN/docs/Glossary/Viewport)（viewport）交叉状态的方法。其祖先元素或视口被称为根（root）。
>
> 当一个 `IntersectionObserver` 对象被创建时，其被配置为监听根中一段给定比例的可见区域。一旦 `IntersectionObserver` 被创建，则无法更改其配置，所以一个给定的观察者对象只能用来监听可见区域的特定变化值；然而，你可以在同一个观察者对象中配置监听多个目标元素。

翻译成大白话来说就是，它可以判断元素是否出现在可视区域中的方法。其中它的参数中 `intersectionRatio` 属性小于等于0则代表它还未出现在可视区域内。

### 代码实现

实现步骤如下：

1. 为图片绑定一个自定义指令，把是否需要懒加载的参数传过去。再通过自定义属性 `data-` 保存该图片的路径
2. 在元素挂载到页面上的钩子函数中判断该图片是否需要懒加载
   - 不需要懒加载，直接获取图片路径并赋值渲染
   - 需要懒加载，把本地保存的占位图片路径赋值过去
3. 通过 `new IntersectionObserver()` 方法中的 `observe()` 判断当前图片节点是否在可视区域，在可视区域内再获取图片的自定义属性并赋值
4. 通过 `unobserve()` 取消监听图片节点

```vue
<template>
  <div class="box">
    <div class="wrapper">
      <img v-lazy="{ nolazy }" :data-src="src" v-bind="$attrs" class="image" />
    </div>
  </div>
</template>

<script>
function lazyBinding(el, binding) {
  const placehold = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'

  const { nolazy } = binding.value

  if (nolazy) return (el.src = el.dataset.src || placehold)

  el.src = placehold

  const obServer = new IntersectionObserver(entries => {
    // 如果 intersectionRatio 为 0，则目标在视野外，
    // 我们不需要做任何事情。
    if (entries.find(v => v.intersectionRatio)) {
      el.src = el.dataset.src || placehold
      obServer.unobserve(el)
    }
  })
  obServer.observe(el)
}

export default {
  inheritAttrs: false,
  props: {
    lazy: {
      type: Boolean,
      default: true,
    },
    src: {
      type: String,
      default: '',
    },
  },
  computed: {
    nolazy() {
      return !this.lazy
    },
  },
  directives: {
    lazy: {
      bind(el, binding) {
        lazyBinding(el, binding)
      },
      componentUpdated(el, binding) {
        lazyBinding(el, binding)
      },
    },
  },
}
</script>

<style scoped lang="scss">
@keyframes fade {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  background-color: rgb(168, 210, 255);
  &.show {
    animation: fade 0.5s ease-in-out;
  }
}
</style>
```

封装成一个子组件，方便后续父组件复用。

## 未完待续......