# 前端性能优化方案

## 资源加载优化

首屏速度是用户体验最关键的一环，资源加载速度是影响性最大的因素。资源的加载速度 = 资源大小 + 网速。资源大小影响的方面有：

1. 压缩
2. 一部分代码分割出来做异步加载，需要使用的时候再加载出来
3. 代码尽量精简

### 加载方式

#### prefetch加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i145fP.png](https://i.imgloc.com/2023/05/07/i145fP.png)

无论是同步还是异步都会先创建一个 `link` 标签去加载，只不过异步的page3会标记 `prefetch` ，没有该标记则说明是需要先加载的，同步加载的资源都加载完毕后再去加载异步加载的资源。

异步加载一般都是使用 `import` 方法来引入使用，例如：

- 组件

  ```js
  components: {
      HelloWord: import('../about/xx.vue')
  }
  ```

- 路由

  ```js
  {
      path: 'about',
      component: () => import('@/views/about')
  }
  ```

**排查方式**

前往开发者 `network` 修改网络为高速3G，刷新页面可以发现，`about` 资源状态处于 `padding` 等待状态，直到同步资源加载完毕才加载。

查看源代码，其引入代码有一个 `typ="prefetch"` 的标识。

#### script加载

假设 page1和page2 是同步加载的，page3是异步加载，则会有以下的流程：

![i14YGz.png](https://i.imgloc.com/2023/05/07/i14YGz.png)

如果是异步状态它不会去加载，等到用户要跳转到 page3 它才会去加载。

`script` 加载方式需要前往 `vue.config.js` 文件修改，代码示例如下：

```js
module.exports = {
    chainWebpack: config => {
        config.plugins.delete('prefetch')
    }
}
```

如果在关闭 `prefetch` 的情况下想要部分路由使用 `prefetch` 加载，可以为其添加注释，代码示例：

```js
{
    path: 'about',
    component: () => import(/*webpackPrefetch:true*/ '@/views/about')
}
```

> 这个是 `webpack` 提供的功能，与 `vue` 无关，如果你是使用 `webpack` 创建的 `react` 项目也需要这么配置。

如果需要开启 `prefetch` 则在 `webpackPrefetch` 方法后添加 `true` （没有 `false` 这个选项）。或者填入数字，表示优先级。数字越大优先级越高，会优先加载（`true` 视为0）。

#### 总结

- script：
  1. 做到了真正的按需引入，用到的时候再加载，不用永不加载，充分减小带宽
  2. 最大的问题在于，切换需要等待，体验感不是很流畅
- prefetch
  1. 充分利用使用者不占用带宽的浏览时间，切换到异步加载的页面是可能已经加载好了，用户体验好
  2. 一些本次行为不会打开的页面也会加载，一定程度上浪费带宽

#### 优化经验

##### 使用按需引入（函数式）的版本

如 `xlsx` 第三方库，有很多方法，我们只用了其中几个方法，但是全部引入他会都打包，项目体积会变大。

```js
import xlsx from 'xlsx'
```

因此可以使用按需引入的方法。方法为：

- 卸载依赖重新安装。目的是安装最新版本，实现按需引入。老版本的库可能不支持该方法）
- 采用解构的方式引入我们需要的方法即可

```js
import {read, utils} from 'xlsx'
```

##### 在组件 `mounted` 阶段再引入库，或者用到这个功能时再引入

有部分功能与页面展示没太大关系，可能功能也不是第一时间使用，因此可以写在函数内，在 `mounted` 阶段引入。

```vue
<script>
    let $;
    
    export default {
    	 mounted() {
		    this.changeTest()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    }
		}
    }
</script>
```

`jquery` 源码是通过 `export default` 导出，因此 `res.default` 才是 `jquery` 方法。`import` 异步引入返回一个 `Promise` ，可以使用 `.then` 获取回调参数。

在外层定义全部变量赋值。

前面的 `xlsx` 也可以使用该方法异步引入，示例代码如下：

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import('jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import('xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

##### 利用prefetch调控加载顺序

```vue
<script>
    let $;
    let utils;
    let read;
    
    export default {
    	 mounted() {
		    this.changeTest()
		    this.changeXlsx()
		},
		methods: {
		    changeTest() {
		        import(/*webpackPrefetch:10*/'jquery').then(res => {
    	            $ = res.default
		            let a = $('.test')
		            a.html('hello')
		        })
		    },
        	 changeXlsx() {
	    	    import(/*webpackPrefetch:1*/'xlsx').then(res => {
        	        // 这里是按需导出，因此不需要default
        	        read = res.read
        	        utils = res.utils
	    	    })
	    	}
		}
    }
</script>
```

## 未完待续......