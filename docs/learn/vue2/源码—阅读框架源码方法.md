# 阅读框架源码方法

## 源码阅读

### 打包入口文件

首先前往 Vue2 的 `github` 下载源码项目，安装依赖。

然后从代码的目录结构入手，先分析每一个文件夹的功能以及包含的内容：

- `bechmarks` ：性能测试

- `dist` ：最终打包出的结果

- `examples` ：官方例子 `demo` 

- `flow` ：类型检测，Vue2 当初没采用 TS，而是采用这个微软出品的类型检测，不过目前没人使用了

- `packages` ：一些写好的包（Vue 源码中包含 `weex` ）

- `scripts` ：所有打包的脚本文件

- `src` ：源代码目录

  一般情况下我们的代码都是放在 `src` 文件夹下，因此它是重点文件夹。打开 `src` 文件夹，分析其下的每个文件夹的功用：

  - `compiler` ：专门用作模板编译
  - `platform` 
  - `server` ：服务端渲染相关
  - `sfc` ：解析单文件组件，如样式 `style` 、模板 `template` 、脚本 `script` 等（要结合 `vue-loader` 使用）
  - `shared` ：模板之间的共享属性和方法

> 找到 `package.json` 文件，查看命令找到打包的入口，在 `srcipts` 文件夹下的 `config.js` 文件。该文件最后的代码如下：

```js
if(process.env.TARGET) {
    module.exports = genConfig(process.env.TARGET)
} else {
    exports.getBuild = getConfig
    exports.getAllBuilds = () => Object.keys(build).map(genConfig)
}
```

从代码可以看成它做了一个判断，是否有打包目标 `TARGET` ，如果有直接使用，没有才通过遍历对象寻找。

查看运行的命令，有两种：运行时如果无法解析 `new Vue` 传入的 `template` ，则会走 `web-runtime` ；否则会执行 `web-full` （`web-runtime` + 模板解析）。

它调用了 `genConfig` 方法，该方法会去 `builds` 对象中找到对象打包目标对象中找到入口文件，部分源码如下：

```js
const builds = {
  // runtime-only build (Browser)
  'runtime-dev': {
    entry: resolve('web/entry-runtime.ts'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // Runtime+compiler development build (Browser)
  'full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.ts'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
}
```

其中 `entry` 是打包的文件文件路径，在 `web` 文件夹下的相应文件。但是 `scripts` 以及外部都没有这个 `web` 文件夹，因此还需要继续寻找。

调用了 `resolve` 函数，把路径传了过去，源码如下：

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}
```

它拿到路径后和 `aliases` 做了拼接处理，因此根据路径查看 `aliases.js` 的代码，如下：

```js
module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  server: resolve('packages/server-renderer/src'),
  sfc: resolve('packages/compiler-sfc/src')
}
```

可以看到其 `web` 实际上是 `src/platforms/web` 路径，现在能够通过拼接，找到对应的打包文件的入口路径了。

查看源码，发现它们都使用了 `runtime` ：

```js
import Vue from './runtime/index'
```

而 `entry-runtime-with-compiler` 的区别是多实现了一个  `compile` API，把 `template` 转化成 `render` 函数。

下面先来看看这个 `compile` API 做了什么处理。源代码如下所示：

```js
// 函数劫持，将原来的mount函数获取到后重写mount函数
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 获取el元素
  el = el && query(el)

  /* istanbul ignore if */
  // 挂载的流程是用一个新生成的dom替换掉老的dom元素
  if (el === document.body || el === document.documentElement) {
    __DEV__ &&
      warn(
        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
      )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) { // 如果有render函数则直接使用用户的render函数
    let template = options.template
    if (template) { // 如果没有render，查看是否有模板
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          // 考虑到 {template: '#template'} 的情况
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (__DEV__ && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果给的模板是一个dom元素，则拿到模板中的内容
        template = template.innerHTML
      } else {
        if (__DEV__) {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // @ts-expect-error
      // 如果没有模板，则使用el对应的template
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile')
      }

      // 直接将模板变成render函数
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: __DEV__,
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  // 调用了挂载
  return mount.call(this, el, hydrating)
}
```

查看其源码不难发现，他只做了一件事情，就是重写了 `$mount` 函数，将 `template` 变成 `render` 函数。这就是 `entry-runtime-width-compiler` 比 `entry-runtime` 命令多出来的区别。

接着我们再往上面看，看一下双方都有的 `runtime/index` 文件内的方法做了什么处理。它是运行时，所谓运行时，就是提供一些 DOM 操作的 API ，比如属性操作、元素操作等，还有一些指令和组件。

其中，部分源码如下所示：

```js
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives) // 添加平台对应的指令和组件
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop // 渲染时会调用的方法，更新时会调用的方法。noop是一个空函数，如果在服务端渲染，则不需要调用方法，因此给一个空函数即可

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined

  // 组件的挂载
  return mountComponent(this, el, hydrating)
}
```

主要是为原型上安装一个 `__patch__` 的方法，判断当前的渲染环境是否在服务器端，如果在服务器端，则执行空函数 `noop` 。

在原型上挂载一个 `$mount` 函数，最终 `return` 导出一个组件的挂载的方法。

但是这还不是入口文件，往上滑发现它从 `core/index` 文件导入方法，因此前往查看它做了什么处理。

打开 `core/index.js` 文件，发现它依旧不是入口文件，做了一个导入导出。该文件增加了两个标识：是否是服务端渲染、服务端渲染的上下文，并且初始化 Vue 的全局 API 。部分源码如下：

```js
initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})
```

根据文件路径继续网上找，查看 `core/instance/index` 文件，发现他没有外部导入 Vue 方法，而是创建了一个 Vue 的构造函数。其源码如下所示：

```js
function Vue(options) {
  if (__DEV__ && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

可以看到其本质上在函数中调用了 `_init()` 初始化的方法，然后调用了几个函数，在 Vue 的原型 `prototype` 上挂载方法。作用分别是：

- `initMixin` ：挂载初始化方法 `_init` 
- `stateMixin` ：挂载 `$set` 、`$delete` 、`$watch` 方法
- `eventsMixin` ：挂载 `$on` 、`$off` 、`$emit` 方法
- `lifecycleMixin` ：挂载 `_update` 、`$forceUpdate` 强制刷新、`$destory` 销毁方法、
- `renderMixin` ：挂载 `$nextTick` 、`_render` 方法

总结出一句就是在扩展原型上的方法。

一图流如下所示：

![一图流](https://pic.imgdb.cn/item/652b962ac458853aef593e21.jpg)

> 里面每一个具体怎么实现？
>
> 1. 如果找了核心流程，可以单独打开源码查看
> 2. 如果不清楚流程，可以写一些测试用例和案例来调试。通过为编译命令行添加 `--sourcemap` 让编译后的源文件可以 `debuggr` 调试

### 全局API分析

看看它的全局 API 是怎么实现的。找到 `src/core/global-api/index.js` 文件，里面有一个 `initClobalAPI()` 函数。

首先它代理了 `config` 方法，用于配置信息，源码如下：

```js
const configDef: Record<string, any> = {}
configDef.get = () => config
if (__DEV__) {
  configDef.set = () => {
    warn(
      'Do not replace the Vue.config object, set individual fields instead.'
    )
  }
}
Object.defineProperty(Vue, 'config', configDef)
```

然后配置了 Vue 中的工具方法，如合并 `extend` 、合并策略 `mergeOptions` 、定义响应式 `defineReactive` 等。还有一些常用的方法，如 `set` 、`delete` 、`nextTick` 等。源码如下：

```js
Vue.util = {
  warn,
  extend,
  mergeOptions,
  defineReactive
}

Vue.set = set
Vue.delete = del
Vue.nextTick = nextTick
```

其中，关于 `nextTick` 可以查看我的博客文档 [nextTick](/learn/杂技拾谈/Vue/$nexttick) 。

再往下是让一个对象变成响应式的方法，源码如下：

```js
Vue.observable = <T>(obj: T): T => {
  observe(obj)
  return obj
}
```

最后在 Vue 方法上通过 `Object.create` 设置空对象 `options` ，并通过循环赋值空对象，并让 `_base` 一直指向 Vue 构造函数。

使用 `extend` 方法挂载 `keep-alive` 方法。

再从其他页面导入对应的方法注册，分别是：

- Vue.use
- Vue.mixin
- Vue.extend
- Vue.component、Vue.directive、Vue.filter

源码如下：

```js
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})

// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue

extend(Vue.options.components, builtInComponents)

initUse(Vue)
initMixin(Vue)
initExtend(Vue)
initAssetRegisters(Vue)
```

### 响应式数组

1. 响应式数据的理解

   `initData` 函数中调用 `observe` 方法回调，对数据作监听。调用 `defineReactive` 方法劫持代理（内部重写了所有属性）。递归增加对象中的对象增加 `geter` 和 `setter` 。

   如果层级过深，则需要考虑优化（递归代理消耗性能）。如果数据不是响应式的就不要放在 `data` 中了。在取值的时候要避免多次取值，如果有些对象放到 `data` 内但不是响应式的，可以考虑 `Object.freeze()` 来冻结对象。

2. 检测数组变化

   Vue2 中检测数组变化没有采用 `defineProperty` ，因为修改索引的情况不多（如果直接采用 `defineProperty` 会浪费大量性能）。采用重写数组的变异方法来实现（函数劫持）。

   ```js
   if (isArray(value)) {
     // 如果是数组，则判断它有没有__proto__对应方法，如果有说明已经代理过了，没有则没代理过，通过拷贝为其赋值
     if (!mock) {
       if (hasProto) {
         ;(value as any).__proto__ = arrayMethods
       } else {
         for (let i = 0, l = arrayKeys.length; i < l; i++) {
           const key = arrayKeys[i]
           def(value, key, arrayMethods[key])
         }
       }
     }
     if (!shallow) {
       this.observeArray(value)
     }
   } else {
     const keys = Object.keys(value)
     for (let i = 0; i < keys.length; i++) {
       const key = keys[i]
       defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock)
     }
   }
   ```

   通过阅读源码可以看出其步骤顺序如下：调用 `initData` 函数，调用 `observe` 回调，对传入的数组进行原型链修改，后续调用的方法都是重写后的方法，对数组中每个对象也再次代理。

### 依赖收集

所谓的依赖收集，实际上是观察者模式。被观察者指代的是数据（即观察数据的变化）；观察者是 `watcher` ，里面可能有渲染逻辑、计算属性、用户 `watcher` 。

观察者要观察数据，则需要通过 `dep` 先收集数据。一个 `watcher` 中需要先可能对应多个数据，`watcher` 中还需要保存 `dep` 。重写渲染的时候可以让属性重新记录 `watcher` 。

> `dep` 与 `watcher` 是多对多的关系，一个 `dep` 对应多个 `watcher` ，一个 `watcher` 内有多个 `dep` 。
>
> 默认渲染时会收集依赖，触发 `get` 方法。数据更新了就找到属性对应的 `watcher` 去触发更新。数据更新了就找到对应的 `watcher` 触发更新。
>
> 如果不触发 `$mount` ，就不会 `render` 更新，也就不会收集依赖。

一图流如下：

![一图流](https://pic.imgdb.cn/item/652ca4efc458853aef7d3cd2.jpg)

一个视图渲染的属性有可能不一样，因此每次都会先清理，然后重新收集依赖。如果不清理，改旧的、现在没用到的属性也会造成视图更新。每次重新渲染都会触发 `getter` 方法，在这个方法收集依赖。

### 模板编译

用户传递的是 `template` 属性，需要将这个 `template` 编译成 `render` 函数。

- 首先转换成 AST 语法树
- 对语法树进行标记（静态节点）
- AST语法树生成 `render` 函数

### 生命周期

在 `src/core/util/options.js` 文件中的 444 行开始，循环父亲和儿子的所有属性，然后调用 `mergeField` 函数做合并操作。源码如下：

```js
const options: ComponentOptions = {} as any
let key
// 循环父亲所有属性
for (key in parent) {
  mergeField(key)
}
// 循环儿子所有属性
for (key in child) {
  if (!hasOwn(parent, key)) {
    mergeField(key)
  }
}
// 策略模式
function mergeField(key: any) {
  const strat = strats[key] || defaultStrat
  options[key] = strat(parent[key], child[key], vm, key)
}
```

而策略模式中默认如果有儿子的属性方法则采用儿子的，没有才使用父亲的属性方法，源码如下：

```js
const defaultStrat = function (parentVal: any, childVal: any): any {
  // 以儿子为主
  return childVal === undefined ? parentVal : childVal
}
```

接下来看看 `strats` 的 `hook` 内封装了啥方法，源码如下：

```js
export function mergeLifecycleHook(
  parentVal: Array<Function> | null,
  childVal: Function | Array<Function> | null
): Array<Function> | null {
  // 获取父亲和儿子的
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal) // 都有就合并
      : isArray(childVal) // 否则看儿子是不是数组，是数组直接用，不是则用数组包裹
      ? childVal
      : [childVal]
    : parentVal
  return res ? dedupeHooks(res) : res
}
```

去到 `src/core/instance/lifecycle.js` 文件，找到生命周期的钩子回调函数，源码如下：

```js
export function callHook(
  vm: Component,
  hook: string,
  args?: any[],
  setContext = true
) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const prev = currentInstance
  setContext && setCurrentInstance(vm)
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, args || null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  setContext && setCurrentInstance(prev)
  popTarget()
}
```

实现原理是利用发布订阅模式，将用户写的钩子维护成一个数组，后续依次调用 `callHook` 。主要依靠的是 `mergeOptions` 方法。

> 为什么有些钩子是先子后父，有些是先父后子？
>
> 主要是看组件是如何渲染的。看下方代码：
>
> ```vue
> <div id="app">
>   <my-button></my-button>
> </div>
> ```
>
> 遇到父组件 `#app` ，开始渲染父组件，触发其 `beforeCreate` 钩子函数。然后遇到子组件 `my-button` ，开始渲染子组件，触发子组件的 `beforeCreate` 钩子函数。
>
> 渲染完毕后触发子组件的 `mounted` 钩子函数，继续往下，渲染父组件，渲染完毕后触发父组件的 `mounted` 。

#### 题外话

一般在哪里发送请求？

`beforeCreate` 生命周期的数据还未实现响应式，从源码下手证明这一点。

在 `src/core/instance/init.js` 文件的 59行左右，函数调用顺序如下：

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate', undefined, false /* setContext */)
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

首先调用 `initLifecycle` 函数，该方法源码如下：

```js
export function initLifecycle(vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._provided = parent ? parent._provided : Object.create(null)
  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

总结下来就是处理组件父子关系，如 `$parent` 、`$children` 等。

然后调用了 `initEvents` 方法函数，该方法主要初始化一些全局方法，如 `$on` 、`$off` 、`$emit` 等。源码如下所示：

```js
export function eventsMixin(Vue: typeof Component) {
  const hookRE = /^hook:/
  Vue.prototype.$on = function() {}
  Vue.prototype.$once = function() {}
  Vue.prototype.$off = function() {}
  Vue.prototype.$emit = function() {}
}
```

然后调用了 `beforeCreate` 生命周期钩子函数，该函数无法获取数据，作用不大，因此 Vue3 把它剔除了。

然后调用了 `initInjections` 方法，该方法主要是注册初始化 `resolve` 、`injections` 、`before` 、`data/props` 、`inject` 等方法。紧接着调用 `initState` 函数方法，此时劫持数据并做响应式处理。执行完毕后调用 `initProvide` 函数，主要实现 `provide` 方法。

再然后才调用 `created` 生命函数，此时拿到的是响应式的属性（不涉及 DOM 渲染），这个 API 可以在服务端渲染中使用。在 Vue3 中改为 `setup` 。

然后代码执行到 `src/core/instance/lifecycle.js` 文件中的 146 行，触发 `beforeMount` 生命周期回调。源码如下：

```js
  vm.$el = el
  if (!vm.$options.render) {
    // @ts-expect-error invalid type
    vm.$options.render = createEmptyVNode
    if (__DEV__) {
      /* istanbul ignore if */
      if (
        (vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el ||
        el
      ) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount')
```

该方法的意义不大，逻辑可以写到 `create` 钩子函数内，获取 DOM 元素并操作的方法可以写到 `mounted` 钩子函数内。

等到 DOM 元素渲染完毕，判断通过，才调用 `mounted` 回调函数。源码如下：

```js
if (vm.$vnode == null) {
  vm._isMounted = true
  callHook(vm, 'mounted')
}
```

当有数据更新时，就会重新渲染，此时会被 `Watcher` 监听到，调用 `beforeUpdate` 钩子函数。源码如下：

```js
const watcherOptions: WatcherOptions = {
  before() {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate')
    }
  }
}
```

执行 `watcher.before()` 方法调用更新，源码如下：

```js
watcher = queue[index]
if (watcher.before) {
  watcher.before()
}
id = watcher.id
has[id] = null
watcher.run()
```

组件更新完毕后调用 `updated` 钩子函数，源码如下：

```js
function callUpdatedHooks(queue: Watcher[]) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}
```

如果销毁组件，最好在 `beforeDestory` 钩子函数上移除定时器等，此时数据还是响应式的。清理完之后调用 `destoryed` 钩子函数，此时数据没有响应式了，但是真实 DOM 还在。源码如下：

```js
Vue.prototype.$destroy = function () {
  const vm: Component = this
  if (vm._isBeingDestroyed) {
    return
  }
  // 调用销毁前
  callHook(vm, 'beforeDestroy')
  vm._isBeingDestroyed = true
  // 移除 $children
  const parent = vm.$parent
  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
    remove(parent.$children, vm)
  }
  vm._scope.stop()
  // 清除数据的响应式
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  vm._isDestroyed = true
  // 把最新的虚拟节点标记为null
  vm.__patch__(vm._vnode, null)
  callHook(vm, 'destroyed')
  // 关闭所有事件
  vm.$off()
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  if (vm.$vnode) {
    vm.$vnode.parent = null
  }
}
```

从上所述，一般最多在 `mounted` 上发请求。代码是同步执行的，请求是异步的，都会等待 `mounted` 之后才获取数据，因此不差 `created` 那点时间。

服务端渲染不都是在 `created` 中（服务端没有 DOM，也没有 `mounted` 钩子）。在哪发请求主要看需要做什么操作。

### mixin原理及作用

通过 `Vue.mixin` 实现逻辑的复用，代码如下：

```js
const request = () => {}

Vue.mixin({
    beforeCreate() {
        this.$request = request()
    },
    beforeDestory() {
        // ...
    }
})

new Vue({
    el: '#app',
    components: {
        my: {
            template: '<button @click="handle"></button>',
            methods: {
                handle() {
                    console.log(this.$request)
                }
            }
        }
    }
})
```

虽然实现了复用，但还是有一点问题：

1. 数据来源不明确。全局 `mixin` 每个组件都可调用，项目大时后续的维护会比较诧异变量的来源
2. 声明的时候可能会导致命名冲突

在 Vue3 中，采用高阶组件的形式，规避这一缺点。

从源码入手分析，在 `src/core/global-api/mixin.js` 文件内，源码如下所示：

```js
export function initMixin(Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
```

这里的 `this` 是谁调用就指向谁，由于该 `mixin` 方法是 Vue 调用的，因此 `this` 实际上是 Vue。最终将 `mixin` 对象和 `Vue.options` 合并在一起。

查看 `mergeOptions` 函数的源码，如下所示：

```js
export function mergeOptions(
  parent: Record<string, any>,
  child: Record<string, any>,
  vm?: Component | null
): ComponentOptions {
  if (__DEV__) {
    checkComponents(child)
  }

  // 合并的是一个组件的构造函数
  if (isFunction(child)) {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  if (!child._base) {
    // 针对组件的 extends 属性来进行合并
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    // 针对组件内部的 mixins 来进行合并，即组件通过 mixins: [xxx] 来注册局部 mixin
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options: ComponentOptions = {} as any
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField(key: any) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

总结下来，`mixin` 核心就是合并属性（内部采用策略模式进行合并），全局 `mixin` 与局部 `mixin` 针对不同的属性有不同的合并策略。

### data为什么是函数

Vue 内部调用的是 `Vue.extend()` 方法，会将用户的选项放到子类上。代码如下所示：

```js
const Vue = {}
Vue.extend = function(options) {
  function Sub() {
    this.data = this.constructor.options.data
  }
  Sub.options = options
  return Sub
}

let Child = Vue.extend({
  data: {
    a: 1
  }
})

let c1 = new Child
let c2 = new Child

console.log(c1.data.a, c2.data.a)
```

但是如果多次调用 `Vue.extend` 方法，不可能每次都返回全新的，应该有一个缓存处理。到源码 `src/core/global-api/extend.js` 文件 20 行处查看，如下：

```js
extendOptions = extendOptions || {}
const Super = this
const SuperId = Super.cid
const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
if (cachedCtors[SuperId]) {
  return cachedCtors[SuperId]
}
```

它通过 ID 查找对应的缓存的值，如果有则取缓存的值。没有才赋新值。

现在返回刚刚我们写的代码，此时输出两个构造函数的 `a` 都是1，但是会有一个问题，他们共享=了同一个数据对象 `data` ，因此修改后会干扰到其他构造函数内的数据。

修改为函数返回对象的形式，确保每一个构造函数的 `data` 都是独立的、互不干扰的数据对象，修改不会造成数据干扰。

Vue 对此做了校验处理，如果是 `newVue` 说明是根组件，可以用对象的形式；如果是组件的形式，则只能是函数的形式。下面看看他的源码：

```js
export function mergeDataOrFn(
  parentVal: any,
  childVal: any,
  vm?: Component
): Function | null {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    return function mergedDataFn() {
      return mergeData(
        isFunction(childVal) ? childVal.call(this, this) : childVal,
        isFunction(parentVal) ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn() {
      const instanceData = isFunction(childVal)
        ? childVal.call(vm, vm)
        : childVal
      const defaultData = isFunction(parentVal)
        ? parentVal.call(vm, vm)
        : parentVal
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}
```

这是最开始 `newVue` 时初始化 `data` 数据的方法，会判断是对象形式还是函数形式。而组件会判断其 `data` 的数据形式，源码如下：

```js
strats.data = function (
  parentVal: any,
  childVal: any,
  vm?: Component
): Function | null {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      __DEV__ &&
        warn(
          'The "data" option should be a function ' +
            'that returns a per-instance value in component ' +
            'definitions.',
          vm
        )

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
}
```

由此可以总结一下，对于根实例而言，`new Vue` 组件是通过同一个构造函数多次创建实例，如果是同一个对象的话那么会被互相影响。每个组件的数据源都是独立的，则每次都调用 `data` 返回一个新的对象。

### nextTick实现原理

`nextTick` 内部采用了异步任务进行包装（多个 `nextTick` 调用会被合并成一次，内部会合并回调）。最后在异步任务中批次处理。

主要应用场景就是异步更新（默认调度的时候，就会添加一个 `nextTick` 任务）用户为了获取最终的渲染结果需要在内部任务执行之后再执行，这时用户需要把对应的逻辑放到 `nextTick` 中。

每次触发更新都会执行 `Watcher` 类的 `update` 方法，源码如下：

```js
update() {
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
```

而方法 `queueWatcher` 则负责过滤同名 `watcher` ，并将多个渲染 `watcher` 去重后放到队列中。源码如下：

```js
export function queueWatcher(watcher: Watcher) {
  // 负责过滤同名 `watcher`
  const id = watcher.id
  if (has[id] != null) {
    return
  }

  if (watcher === Dep.target && watcher.noRecurse) {
    return
  }

  has[id] = true
  if (!flushing) {
    // 多个渲染 `watcher` 去重后放到队列
    queue.push(watcher)
  } else {
    let i = queue.length - 1
    while (i > index && queue[i].id > watcher.id) {
      i--
    }
    queue.splice(i + 1, 0, watcher)
  }
  if (!waiting) {
    waiting = true

    if (__DEV__ && !config.async) {
      flushSchedulerQueue()
      return
    }
   
    // 每一次更新视图后内部会开启一个nextTick
    nextTick(flushSchedulerQueue)
  }
}
```

前往文件 `src/core/util/next-tick.js` 文件中，找到 `necttick` 函数，源码如下：

```js
export function nextTick(cb?: (...args: any[]) => any, ctx?: object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e: any) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

它还对当前浏览器能否使用 `Promise` 做了判断，如果可以使用则为微任务，不可使用则改为宏任务。源码如下：

```js
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (
  !isIE &&
  typeof MutationObserver !== 'undefined' &&
  (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')
) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

了解完源码后下方这道题就浅显易懂了，先看代码：

```js
const vm = new Vue({
    data() {
        return {
            a: 1
        }
    }
})

vm.$nextTick(() => {
    console.log(vm.a)
})

vm.a = 100

vm.$nextTick(() => {
    console.log(vm.a)
})
```

根据源码可知，他会开辟一个数组队列，一次把任务推送到数组队列中。首先推送第一次的 `nextTick` ，然后推送更新操作，最后推送第二次的 `nextTick` 。

因此先打印1，然后修改值为100，再打印100。

### watch与computed

#### 原理

下面来看看 `computed` 和 `watch` 的源码。首先来到 `src/core/instance/state.js` 文件内，找到 `initState` 函数，里面有计算属性和侦听器的挂载，源码如下：

```js
if (opts.computed) initComputed(vm, opts.computed)
if (opts.watch && opts.watch !== nativeWatch) {
  initWatch(vm, opts.watch)
}
```

可以看到计算属性的方法是在侦听器前挂载的，因为侦听器能够侦听计算属性变量的变化，因此需要计算属性方法先执行。

接着执行 `initComputed` 方法，源码如下：

```js
function initComputed(vm: Component, computed: Object) {
  const watchers = (vm._computedWatchers = Object.create(null))
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = isFunction(userDef) ? userDef : userDef.get
    if (__DEV__ && getter == null) {
      warn(`Getter is missing for computed property "${key}".`, vm)
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }

    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (__DEV__) {
      if (key in vm.$data) {
        warn(`The computed property "${key}" is already defined in data.`, vm)
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(`The computed property "${key}" is already defined as a prop.`, vm)
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(
          `The computed property "${key}" is already defined as a method.`,
          vm
        )
      }
    }
  }
}
```

可以看到它首先创建一个空对象 `watchers` ，用于后续保存每一项计算属性。循环遍历 `computed` 计算属性对象，判断其类型是函数型还是对象型，获取相对应的值。

紧接着判断其是否是 `dirty` ，如果是 `dirty` 说明该属性已经被修改了，走正常流程更新数据；否则值没变化，用之前缓存的数据即可。源码如下：

```js
function createComputedGetter(key) {
  return function computedGetter() {
    const watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        if (__DEV__ && Dep.target.onTrack) {
          Dep.target.onTrack({
            effect: Dep.target,
            target: this,
            type: TrackOpTypes.GET,
            key
          })
        }
        watcher.depend()
      }
      return watcher.value
    }
  }
}
```

判断当前的变量是计算属性还是 `data` 内的变量则通过传值处理，如果是计算属性，底层会传递一个 `lazy` 的参数，判断 `lazy` 是否为 `true` ，如果为真说明当前的变量是计算属性。源码如下：

```js
// 为真说明是计算属性，不立即执行；为假说明是data内的数据，调用get方法劫持代理
this.value = this.lazy ? undefined : this.get()

// ...

update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
```

计算属性的底层逻辑梳理了一遍，现在看看侦听器 `watch` 的底层逻辑。同样在 `state.js` 文件中，找到 `initWatch` 方法，源码如下：

```js
function initWatch(vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    if (isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i])
      }
    } else {
      createWatcher(vm, key, handler)
    }
  }
}

function createWatcher(
  vm: Component,
  expOrFn: string | (() => any),
  handler: any,
  options?: Object
) {
  if (isPlainObject(handler)) {
    options = handler
    handler = handler.handler
  }
  if (typeof handler === 'string') {
    handler = vm[handler]
  }
  return vm.$watch(expOrFn, handler, options)
}
```

它也是循环遍历 `watch` 侦听器对象，如果是数组，循环创建 `watcher` ；如果是一个则直接创建 `watcher` 。

把每一项侦听器方法判断其类型，获取到对应的值后最终走 `vm.$watch()` 方法。方法源码如下：

```js
Vue.prototype.$watch = function (
  expOrFn: string | (() => any),
  cb: any,
  options?: Record<string, any>
): Function {
  const vm: Component = this
  if (isPlainObject(cb)) {
    return createWatcher(vm, expOrFn, cb, options)
  }
  options = options || {}
  options.user = true
  const watcher = new Watcher(vm, expOrFn, cb, options)
  if (options.immediate) {
    const info = `callback for immediate watcher "${watcher.expression}"`
    pushTarget()
    invokeWithErrorHandling(cb, vm, [watcher.value], vm, info)
    popTarget()
  }
  return function unwatchFn() {
    watcher.teardown()
  }
}
```

可以看到，首先调用 `Watcher` 类收集依赖，然后判断是否需要立即执行 `immediate` ，最后返回一个销毁侦听的事件。`deep` 属性的实现原理源码在 `src/core/observe/watcher.js` 文件内，源码如下：

```js
if (this.deep) {
  traverse(value)
}
```

通过递归实现深度监听。

#### 异同点

相同点：二者底层都会创建一个 `watcher` （用法的区别，`computed` 定义的属性可以在模板中使用，`watch` 不能在视图中使用）

不同点：

- `computed` 默认不会立即执行，只有取值的时候才会执行。内部会有唯一一个 `dirty` 属性，来控制依赖的值是否发生变化，默认计算属性需要同步返回结果（有个包就是让  `computed` 变成异步的）
- `watch` 默认用户会提供一个回调函数，数据变化了就调用这个回调。通过监控某个数据的变化，数据变化执行某些操作。

### set的实现

`Vue.set` 方法是 Vue 中的一个补丁方法，正常情况下添加属性是不会触发更新的，数组无法监控到索引和长度的变化。

底层给每个对象都添加了一个 Dep 属性，触发更新时会调用 `dep.notify()` 方法，更新数据，代码如下：

```js
const vm = new Vue({
    data() {
        return {
            obj: {
                a: 1
            }
        }
    }
})

vm.obj.b = 100 // js可以获取，视图不会更新
vm.obj.__ob__.dep.notify() // 实现视图更新
```

因此 `Vue.set` 方法无非时通过上方的逻辑思路实现的。源码也是这么处理的，如下所示：

```js
export function set(
  target: any[] | Record<string, any>,
  key: any,
  val: any
): any {
  if (__DEV__ && (isUndef(target) || isPrimitive(target))) {
    warn(
      `Cannot set reactive property on undefined, null, or primitive value: ${target}`
    )
  }
  if (isReadonly(target)) {
    __DEV__ && warn(`Set operation on key "${key}" failed: target is readonly.`)
    return
  }
  const ob = (target as any).__ob__
  // 如果是数组的修改，如 vm.arr[0] = 100 ，修改为 vm.arr.splice(0,1,100) 因为 splice 方法是重写过的了
  if (isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    if (ob && !ob.shallow && ob.mock) {
      observe(val, false, true)
    }
    return val
  }

  // 已有的属性直接修改即可
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }

  // 不建议重写整个data对象，如 $set(vm, 'data', {}) 因为性能消耗很严重
  if ((target as any)._isVue || (ob && ob.vmCount)) {
    __DEV__ &&
      warn(
        'Avoid adding reactive properties to a Vue instance or its root $data ' +
          'at runtime - declare it upfront in the data option.'
      )
    return val
  }
  // 不是响应式数据，直接添加
  if (!ob) {
    target[key] = val
    return val
  }
  // 变成响应式数据
  defineReactive(ob.value, key, val, undefined, ob.shallow, ob.mock)
  // 触发视图更新
  if (__DEV__) {
    ob.dep.notify({
      type: TriggerOpTypes.ADD,
      target: target,
      key,
      newValue: val,
      oldValue: undefined
    })
  } else {
    ob.dep.notify()
  }
  return val
}
```

> Vue3 不需要此方法了，修改为 `proxy` 代理对象本身。

### 虚拟DOM的意义

实际业务中可能会针对不同的平台来使用不同的标签文本（`weex` 、`web` 、小程序），虚拟 DOM 可以跨平台，不需要考虑平台问题。

不用关心兼容性，可以在上层将对应的渲染方法传递过来，通知虚拟 DOM 渲染即可。

Diff 算法针对更新的时候，有了虚拟 DOM 之后可以通过 Diff 算法来找到最后的差异进行修改真实 DOM 。（类似于在真实 DOM 之间做了一个缓存）

### diff算法

Diff 算法特点就是平级比较，内部采用了双指针方式进行优化，优化了常见的操作。采用了递归比较的方式。

#### 针对一个节点的diff算法

先拿出根节点来进行比较，如果是同一个节点则比较属性，如果不是同一个节点则直接换成最新的即可。

同一个节点比较属性后，复用老节点。

#### 比较儿子

一方有儿子，另一方没有，则作删除或添加的操作。

两方都有儿子：

- 优先比较头头、尾尾、头尾尾头的交叉对比
- 做一个映射表，用心的去映射表中查找此元素是否存在，存在则移动不存在则插入，最后删除多余的
- 会有多移动的情况。O(n) 复杂度的比较

源码如下：

```js
const oldCh = oldVnode.children // 老的儿子
const ch = vnode.children // 新儿子
// 调用一系列的更新方法
if (isDef(data) && isPatchable(vnode)) {
  for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
  if (isDef((i = data.hook)) && isDef((i = i.update))) i(oldVnode, vnode)
}
// vnode不是文本
if (isUndef(vnode.text)) {
  // 两边都有儿子
  if (isDef(oldCh) && isDef(ch)) {
    if (oldCh !== ch)
      updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
  } else if (isDef(ch)) {
    if (__DEV__) {
      checkDuplicateKeys(ch)
    }
    // 新的有，老的没有，添加节点
    if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
    addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
  } else if (isDef(oldCh)) {
    // 如果老的有,新的没有,则移除
    removeVnodes(oldCh, 0, oldCh.length - 1)
  } else if (isDef(oldVnode.text)) {
    // 如果老的是文本,则清空文本
    nodeOps.setTextContent(elm, '')
  }
} else if (oldVnode.text !== vnode.text) {
  // 文本不一致,则设置文本
  nodeOps.setTextContent(elm, vnode.text)
}
if (isDef(data)) {
  if (isDef((i = data.hook)) && isDef((i = i.postpatch))) i(oldVnode, vnode)
}
```

#### 题外话

既然数据劫持能够保持数据的响应式，那么为什么还需要虚拟 DOM 进行 Diff 检测差异呢？

如果给每一个属性都增加 `watcher` ，粒度太小不好控制；降低 `watcher` 数量（每一个组件都有一个 `watcher` ，一个变量变化更新该组件的视图）。再通过 Diff 算法优化渲染过程，减少视图更新的消耗，通过 Diff 算法和响应式原理折中处理。

key的原理和作用？

方法 `isSameVnode` 中会根据 `key` 来判断两个元素是否是同一个元素，`key` 不同说明不是同一个 元素。`key` 在动态列表中不要使用索引，使用 `key` 尽量保证其唯一性，可以优化 `diff` 算法。

### 组件化

#### 特点

组件的优点：组件的复用可以根据数据渲染对应的组件，把组件相关的内容放在一起（方便复用）。合理规划组件，可以做到更新的时候是组件级更新（特性、属性、事件、插槽）。

Vue 中怎么样处理组件？

1. `Vue.extend` 根据用户传入的对象生成一个组件的构造函数
2. 根据组件产生对应的虚拟节点
3. 做组件初始化，将虚拟节点转化成真实节点（组件的 `init` 方法）

#### 渲染流程

先写一段组件化的 Vue 代码，如下：

```vue
<div id="app">
  <my></my>
</div>

<script>
const vm = new Vue({
  el: '#app',
  // vm.$options.components = {my: 模板}
  components: {
    my: {
      template: '<div>my-component</div>'
    }
  }
})
</script>
```

1. `vm.$options.components = {my: 模板}`
2. 创建对应的虚拟节点，例如 `{tag: 'my', data: {}, componentOptions: {Ctor:Vue.extend({my: 模板})}}` 
3. 调用 `createComponent` 方法函数创建真实节点，然后调用 `init` 方法挂载
4. `vm.$el` 插入到父元素中

#### 更新流程

更新的几种情况：

1. 父传子数据更新，收集依赖
2. 属性更新，给组件传入属性，属性变化后触发更新
3. 插槽变化

重点聊聊属性更新，更新逻辑都在 `patch` 函数中。去到 `src/core/vdom/patch.js` 文件，找到 `patch` 函数，部分源码如下：

```js
if (!isRealElement && sameVnode(oldVnode, vnode)) {
  // patch existing root node
  patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
}
```

调用 `patchVnode` 方法判断新旧子节点的异同，如果父传子的数据发生变化，，则调用 `prepatch` 方法。源码如下所示：

```js
function isDef<T>(v: T): v is NonNullable<T> {
  return v !== undefined && v !== null
}

let i
const data = vnode.data
if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
  i(oldVnode, vnode)
}
```

而 `prepatch` 方法则非常暴力的做一件事情：把旧的实例赋值给新的实例，实例复用了也就意味着 `componsnetInstance.$el` 也复用了。其本质的作用就是复用组件的实例，并且可以去更新属性、事件、插槽。

复用完之后把对应的孩子、数据、事件等传参调用 `updateChildComponent` 方法。源码如下：

```js
prepatch(oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
  const options = vnode.componentOptions
  const child = (vnode.componentInstance = oldVnode.componentInstance)
  updateChildComponent(
    child,
    options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
  )
},
```

`updateChildComponent` 方法主要做以下几件事情：

1. 把变量的响应式先去掉，因为属性是在父组件中定义的，传递给子组件。父组件定义的数据已经是响应式了，数据变化会自动更新
2. 获取到父传子的数据对象
3. 循环遍历，一一校验所传的属性名和值
4. 更新完毕后恢复响应式

> 总结
>
> - 组件更新会触发组件的 `prepatch` 方法，会复用组件，并且比较组件的属性、事件、插槽
> - 父组件给子组件传递的属性 `prop` 是响应式的，模板中使用会做依赖收集，手机自己的组件 `watcher` 
> - 稍后组件更新了会重新给 `props` 赋值，赋值完成后会触发 `watcher` 重新更新

#### 异步组件原理

Vue 中异步组件写法有很多，主要用作大的组件可以异步加载比较大的组件，如 `markdown` 组件、`editor` 组件等。

先渲染一个注释标签，等组件加载完毕，最后再重新渲染 `forceUpdate` （图片懒加载）。使用异步组件会配合 `webpack` 。

Vue2 官方文档写法如下：

```js
Vue.component('async-example', function(resolve, reject) {
    setTimeout(function() {
        resolve({
            template: `<div>I am async!</div>`
        })
    }, 1000)
})
```

可以看到，其参数二不再是一个对象，而是一个工厂函数，收到一个 `resolve` 回调，也可以调用 `reject` 表示调用失败。

也可以在工厂函数中返回一个 `Promise` ，写法如下：

```js
Vue.component('async-example', () => {
    component: import('./my-async-example'),
    loading: {
        template: '<div>loading</div>'
    }, // 加载中的组件
    error: ErrorComponent, // 加载失败的组件
    delay: 200, // 加载时间
    timeout: 3000 // 超时时间
})
```

从源码入手，梳理整个流程。前面介绍到，Vue 创建组件时，会调用 `Vue.extend` 方法，那是因为底层代码有做了一个类型判断，如果是对象类型，直接调用 `extend` 方法。但异步组件是函数型，因此不会走这一步。源码如下：

```js
if (isObject(Ctor)) {
  Ctor = baseCtor.extend(Ctor as typeof Component)
}
```

它会继续往下走，判断是否有 `cid` ，没有 `cid` 说明是异步组件，调用 `resolveAsyncComponent` 方法，返回值赋值给 `Ctor` 。然后再做判断，如果此时 `Ctor` 还是 `undefined` ，则调用 `createAsyncPlaceholder` 方法。源码如下：

```js
if (isUndef(Ctor.cid)) {
  asyncFactory = Ctor
  Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
  if (Ctor === undefined) {
    return createAsyncPlaceholder(asyncFactory, data, context, children, tag)
  }
}
```

`resolveAsyncComponent` 函数源码如下所示：

```js
export function resolveAsyncComponent(
  factory: { (...args: any[]): any; [keye: string]: any },
  baseCtor: typeof Component
): typeof Component | void {
  // 如果factory.error，就直接渲染错误组件
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  // 如果factory.resolved，就直接渲染成功
  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  const owner = currentRenderingInstance
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    factory.owners.push(owner)
  }

  // 如果factory.loading，就直接渲染loading组件
  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    const owners = (factory.owners = [owner])
    let sync = true
    let timerLoading: number | null = null
    let timerTimeout: number | null = null

    owner.$on('hook:destroyed', () => remove(owners, owner))

    // 强制更新
    const forceRender = (renderCompleted: boolean) => {
      for (let i = 0, l = owners.length; i < l; i++) {
        owners[i].$forceUpdate()
      }

      if (renderCompleted) {
        owners.length = 0
        if (timerLoading !== null) {
          clearTimeout(timerLoading)
          timerLoading = null
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout)
          timerTimeout = null
        }
      }
    }

    // 传递给用户的resolve
    const resolve = once((res: Object | Component) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true)
      } else {
        owners.length = 0
      }
    })

    // 传递给用户的reject
    const reject = once(reason => {
      __DEV__ &&
        warn(
          `Failed to resolve async component: ${String(factory)}` +
            (reason ? `\nReason: ${reason}` : '')
        )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender(true)
      }
    })

    // 让函数执行，返回resolve或reject
    const res = factory(resolve, reject)

    if (isObject(res)) {
      if (isPromise(res)) {
        // 是promise就调用promise.then。如果成功则将获取到的结果赋予给 factory.resolved，即对应的组件
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isPromise(res.component)) {
        // 用户自己写的特殊的组件，是一个promise
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          // 将组件的loading赋予给factory.loadingComp
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            // @ts-expect-error NodeJS timeout type
            timerLoading = setTimeout(() => {
              timerLoading = null
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender(false)
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(() => {
            timerTimeout = null
            if (isUndef(factory.resolved)) {
              reject(__DEV__ ? `timeout (${res.timeout}ms)` : null)
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // 默认返回一个loading
    return factory.loading ? factory.loadingComp : factory.resolved
  }
}
```



> 总结
>
> 异步组件默认不会调用 `Vue.extend` 方法，所有 `Ctor` 上没有 `cid` 属性，没有 `cid` 属性的就是异步组件。
>
> 先渲染一个占位符组件，但是如果有 `loading` 会先渲染 `loading` ，第一轮就结束了。
>
> 如果用户调用了 `resolve` ，会将结果赋予给 `factory.resolved` 上面，强制重新渲染。重新渲染时候再次进入到 `resolveAsyncComponent` 中，会直接到 `factory.resolved` 结果来渲染。

#### 函数式组件优势及原理

函数组件与类组件相比，没有 `this` ，没有所谓的状态，没有 `sub` 实例，没有生命周期 `beforeCreate` 、`created` 等等。优点在于性能好，不需要创建 `watcher` 。

由上方的描述不难看出，函数式组件是单纯的无状态组件，没有其他的操作，因此其性能高。源码如下：

```js
export function createFunctionalComponent(
  Ctor: typeof Component,
  propsData: Object | undefined,
  data: VNodeData,
  contextVm: Component,
  children?: Array<VNode>
): VNode | Array<VNode> | void {
  const options = Ctor.options
  const props = {}
  const propOptions = options.props
  if (isDef(propOptions)) {
    for (const key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject)
    }
  } else {
    if (isDef(data.attrs)) mergeProps(props, data.attrs)
    if (isDef(data.props)) mergeProps(props, data.props)
  }

  // 创建属性上下文
  const renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  )

  // 函数式组件对应的vnode
  const vnode = options.render.call(null, renderContext._c, renderContext)

  // 如果符合，直接返回
  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(
      vnode,
      data,
      renderContext.parent,
      options,
      renderContext
    )
  } else if (isArray(vnode)) {
    const vnodes = normalizeChildren(vnode) || []
    const res = new Array(vnodes.length)
    for (let i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(
        vnodes[i],
        data,
        renderContext.parent,
        options,
        renderContext
      )
    }
    return res
  }
}
```

> 总结
>
> 函数式组件就是调用 `render` 拿到返回结果渲染，所以性能高。

#### 组件传值的方式及之间区别

- `props` 父传子

  `props` 会分类，在父组件传递的参数中，只有子组件内 `props` 声明了的才会归为 `props` 一类，剩下的归为 `$attrs` 一类。如下：

  ```vue
  <div id="app">
    <son a=1 b=2 c=3 />
  </div>
  
  <script>
  new Vue({
    el: '#app',
    components: {
      son: {
        props: ['a', 'b'],
        template: '<div>son</div>'
      }
    }
  })
  </script>
  ```

  上方示例代码中 `a` 和 `b` 是 `props` 一类，`c` 为 `$attes` 一类。源码如下所示：

  ```js
  export function extractPropsFromVNodeData(
    data: VNodeData,
    Ctor: typeof Component,
    tag?: string
  ): object | undefined {
    const propOptions = Ctor.options.props
    if (isUndef(propOptions)) {
      return
    }
    const res = {}
    const { attrs, props } = data
    if (isDef(attrs) || isDef(props)) {
      for (const key in propOptions) {
        const altKey = hyphenate(key)
        if (__DEV__) {
          const keyInLowerCase = key.toLowerCase()
          if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
            tip(
              `Prop "${keyInLowerCase}" is passed to component ` +
                `${formatComponentName(
                  // @ts-expect-error tag is string
                  tag || Ctor
                )}, but the declared prop name is` +
                ` "${key}". ` +
                `Note that HTML attributes are case-insensitive and camelCased ` +
                `props need to use their kebab-case equivalents when using in-DOM ` +
                `templates. You should probably use "${altKey}" instead of "${key}".`
            )
          }
        }
        checkProp(res, props, key, altKey, true) ||
          checkProp(res, attrs, key, altKey, false)
      }
    }
    return res
  }
  ```

  拿到父传子的数据后循环遍历校验（如转为小写后查看是否存在该属性等），创建好组件的虚拟节点，有一个属性 `{componentOptions: {propsData}}` 。然后分类出 `props` 和 `attrs` ，

- `emit` 子传父