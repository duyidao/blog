# 阅读框架源码方法

## 源码阅读

### 打包入口文件

首先前往 Vue2 的 `github` 下载源码项目，安装依赖。

然后从代码的目录结构入手，先分析每一个文件夹的功能以及包含的内容：

- `bechmarks` ：性能测试

- `dist` ：最终打包出的结果

- `examples` ：官方例子 `demo` 

- `flow` ：类型检测，Vue2 当初没采用 TS，而是采用这个微软出品的类型检测，不过目前没人使用了

- `packages` ：一些写好的包（Vue 源码中包含 `weex` ）

- `scripts` ：所有打包的脚本文件

- `src` ：源代码目录

  一般情况下我们的代码都是放在 `src` 文件夹下，因此它是重点文件夹。打开 `src` 文件夹，分析其下的每个文件夹的功用：

  - `compiler` ：专门用作模板编译
  - `platform` 
  - `server` ：服务端渲染相关
  - `sfc` ：解析单文件组件，如样式 `style` 、模板 `template` 、脚本 `script` 等（要结合 `vue-loader` 使用）
  - `shared` ：模板之间的共享属性和方法

> 找到 `package.json` 文件，查看命令找到打包的入口，在 `srcipts` 文件夹下的 `config.js` 文件。该文件最后的代码如下：

```js
if(process.env.TARGET) {
    module.exports = genConfig(process.env.TARGET)
} else {
    exports.getBuild = getConfig
    exports.getAllBuilds = () => Object.keys(build).map(genConfig)
}
```

从代码可以看成它做了一个判断，是否有打包目标 `TARGET` ，如果有直接使用，没有才通过遍历对象寻找。

查看运行的命令，有两种：运行时如果无法解析 `new Vue` 传入的 `template` ，则会走 `web-runtime` ；否则会执行 `web-full` （`web-runtime` + 模板解析）。

它调用了 `genConfig` 方法，该方法会去 `builds` 对象中找到对象打包目标对象中找到入口文件，部分源码如下：

```js
const builds = {
  // runtime-only build (Browser)
  'runtime-dev': {
    entry: resolve('web/entry-runtime.ts'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // Runtime+compiler development build (Browser)
  'full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.ts'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
}
```

其中 `entry` 是打包的文件文件路径，在 `web` 文件夹下的相应文件。但是 `scripts` 以及外部都没有这个 `web` 文件夹，因此还需要继续寻找。

调用了 `resolve` 函数，把路径传了过去，源码如下：

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}
```

它拿到路径后和 `aliases` 做了拼接处理，因此根据路径查看 `aliases.js` 的代码，如下：

```js
module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  server: resolve('packages/server-renderer/src'),
  sfc: resolve('packages/compiler-sfc/src')
}
```

可以看到其 `web` 实际上是 `src/platforms/web` 路径，现在能够通过拼接，找到对应的打包文件的入口路径了。

查看源码，发现它们都使用了 `runtime` ：

```js
import Vue from './runtime/index'
```

而 `entry-runtime-with-compiler` 的区别是多实现了一个  `compile` API，把 `template` 转化成 `render` 函数。

下面先来看看这个 `compile` API 做了什么处理。源代码如下所示：

```js
// 函数劫持，将原来的mount函数获取到后重写mount函数
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 获取el元素
  el = el && query(el)

  /* istanbul ignore if */
  // 挂载的流程是用一个新生成的dom替换掉老的dom元素
  if (el === document.body || el === document.documentElement) {
    __DEV__ &&
      warn(
        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
      )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) { // 如果有render函数则直接使用用户的render函数
    let template = options.template
    if (template) { // 如果没有render，查看是否有模板
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          // 考虑到 {template: '#template'} 的情况
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (__DEV__ && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果给的模板是一个dom元素，则拿到模板中的内容
        template = template.innerHTML
      } else {
        if (__DEV__) {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // @ts-expect-error
      // 如果没有模板，则使用el对应的template
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile')
      }

      // 直接将模板变成render函数
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: __DEV__,
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  // 调用了挂载
  return mount.call(this, el, hydrating)
}
```

查看其源码不难发现，他只做了一件事情，就是重写了 `$mount` 函数，将 `template` 变成 `render` 函数。这就是 `entry-runtime-width-compiler` 比 `entry-runtime` 命令多出来的区别。

接着我们再往上面看，看一下双方都有的 `runtime/index` 文件内的方法做了什么处理。它是运行时，所谓运行时，就是提供一些 DOM 操作的 API ，比如属性操作、元素操作等，还有一些指令和组件。

其中，部分源码如下所示：

```js
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives) // 添加平台对应的指令和组件
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop // 渲染时会调用的方法，更新时会调用的方法。noop是一个空函数，如果在服务端渲染，则不需要调用方法，因此给一个空函数即可

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined

  // 组件的挂载
  return mountComponent(this, el, hydrating)
}
```

主要是为原型上安装一个 `__patch__` 的方法，判断当前的渲染环境是否在服务器端，如果在服务器端，则执行空函数 `noop` 。

在原型上挂载一个 `$mount` 函数，最终 `return` 导出一个组件的挂载的方法。

但是这还不是入口文件，往上滑发现它从 `core/index` 文件导入方法，因此前往查看它做了什么处理。

打开 `core/index.js` 文件，发现它依旧不是入口文件，做了一个导入导出。该文件增加了两个标识：是否是服务端渲染、服务端渲染的上下文，并且初始化 Vue 的全局 API 。部分源码如下：

```js
initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})
```

根据文件路径继续网上找，查看 `core/instance/index` 文件，发现他没有外部导入 Vue 方法，而是创建了一个 Vue 的构造函数。其源码如下所示：

```js
function Vue(options) {
  if (__DEV__ && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

可以看到其本质上在函数中调用了 `_init()` 初始化的方法，然后调用了几个函数，在 Vue 的原型 `prototype` 上挂载方法。作用分别是：

- `initMixin` ：挂载初始化方法 `_init` 
- `stateMixin` ：挂载 `$set` 、`$delete` 、`$watch` 方法
- `eventsMixin` ：挂载 `$on` 、`$off` 、`$emit` 方法
- `lifecycleMixin` ：挂载 `_update` 、`$forceUpdate` 强制刷新、`$destory` 销毁方法、
- `renderMixin` ：挂载 `$nextTick` 、`_render` 方法

总结出一句就是在扩展原型上的方法。

一图流如下所示：

![一图流](https://pic.imgdb.cn/item/652b962ac458853aef593e21.jpg)

> 里面每一个具体怎么实现？
>
> 1. 如果找了核心流程，可以单独打开源码查看
> 2. 如果不清楚流程，可以写一些测试用例和案例来调试。通过为编译命令行添加 `--sourcemap` 让编译后的源文件可以 `debuggr` 调试

### 全局API分析

看看它的全局 API 是怎么实现的。找到 `src/core/global-api/index.js` 文件，里面有一个 `initClobalAPI()` 函数。

首先它代理了 `config` 方法，用于配置信息，源码如下：

```js
const configDef: Record<string, any> = {}
configDef.get = () => config
if (__DEV__) {
  configDef.set = () => {
    warn(
      'Do not replace the Vue.config object, set individual fields instead.'
    )
  }
}
Object.defineProperty(Vue, 'config', configDef)
```

然后配置了 Vue 中的工具方法，如合并 `extend` 、合并策略 `mergeOptions` 、定义响应式 `defineReactive` 等。还有一些常用的方法，如 `set` 、`delete` 、`nextTick` 等。源码如下：

```js
Vue.util = {
  warn,
  extend,
  mergeOptions,
  defineReactive
}

Vue.set = set
Vue.delete = del
Vue.nextTick = nextTick
```

其中，关于 `nextTick` 可以查看我的博客文档 [nextTick](/learn/杂技拾谈/Vue/$nexttick) 。

再往下是让一个对象变成响应式的方法，源码如下：

```js
Vue.observable = <T>(obj: T): T => {
  observe(obj)
  return obj
}
```

最后在 Vue 方法上通过 `Object.create` 设置空对象 `options` ，并通过循环赋值空对象，并让 `_base` 一直指向 Vue 构造函数。

使用 `extend` 方法挂载 `keep-alive` 方法。

再从其他页面导入对应的方法注册，分别是：

- Vue.use
- Vue.mixin
- Vue.extend
- Vue.component、Vue.directive、Vue.filter

源码如下：

```js
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})

// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue

extend(Vue.options.components, builtInComponents)

initUse(Vue)
initMixin(Vue)
initExtend(Vue)
initAssetRegisters(Vue)
```

### 响应式数组

1. 响应式数据的理解

   `initData` 函数中调用 `observe` 方法回调，对数据作监听。调用 `defineReactive` 方法劫持代理（内部重写了所有属性）。递归增加对象中的对象增加 `geter` 和 `setter` 。

   如果层级过深，则需要考虑优化（递归代理消耗性能）。如果数据不是响应式的就不要放在 `data` 中了。在取值的时候要避免多次取值，如果有些对象放到 `data` 内但不是响应式的，可以考虑 `Object.freeze()` 来冻结对象。

2. 检测数组变化

   Vue2 中检测数组变化没有采用 `defineProperty` ，因为修改索引的情况不多（如果直接采用 `defineProperty` 会浪费大量性能）。采用重写数组的变异方法来实现（函数劫持）。

   ```js
   if (isArray(value)) {
     // 如果是数组，则判断它有没有__proto__对应方法，如果有说明已经代理过了，没有则没代理过，通过拷贝为其赋值
     if (!mock) {
       if (hasProto) {
         ;(value as any).__proto__ = arrayMethods
       } else {
         for (let i = 0, l = arrayKeys.length; i < l; i++) {
           const key = arrayKeys[i]
           def(value, key, arrayMethods[key])
         }
       }
     }
     if (!shallow) {
       this.observeArray(value)
     }
   } else {
     const keys = Object.keys(value)
     for (let i = 0; i < keys.length; i++) {
       const key = keys[i]
       defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock)
     }
   }
   ```

   通过阅读源码可以看出其步骤顺序如下：调用 `initData` 函数，调用 `observe` 回调，对传入的数组进行原型链修改，后续调用的方法都是重写后的方法，对数组中每个对象也再次代理。

### 依赖收集