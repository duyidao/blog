# 阅读框架源码方法

## 源码阅读

### 打包入口文件

首先前往 Vue2 的 `github` 下载源码项目，安装依赖。

然后从代码的目录结构入手，先分析每一个文件夹的功能以及包含的内容：

- `bechmarks` ：性能测试

- `dist` ：最终打包出的结果

- `examples` ：官方例子 `demo` 

- `flow` ：类型检测，Vue2 当初没采用 TS，而是采用这个微软出品的类型检测，不过目前没人使用了

- `packages` ：一些写好的包（Vue 源码中包含 `weex` ）

- `scripts` ：所有打包的脚本文件

- `src` ：源代码目录

  一般情况下我们的代码都是放在 `src` 文件夹下，因此它是重点文件夹。打开 `src` 文件夹，分析其下的每个文件夹的功用：

  - `compiler` ：专门用作模板编译
  - `platform` 
  - `server` ：服务端渲染相关
  - `sfc` ：解析单文件组件，如样式 `style` 、模板 `template` 、脚本 `script` 等（要结合 `vue-loader` 使用）
  - `shared` ：模板之间的共享属性和方法

> 找到 `package.json` 文件，查看命令找到打包的入口，在 `srcipts` 文件夹下的 `config.js` 文件。该文件最后的代码如下：

```js
if(process.env.TARGET) {
    module.exports = genConfig(process.env.TARGET)
} else {
    exports.getBuild = getConfig
    exports.getAllBuilds = () => Object.keys(build).map(genConfig)
}
```

从代码可以看成它做了一个判断，是否有打包目标 `TARGET` ，如果有直接使用，没有才通过遍历对象寻找。

查看运行的命令，有两种：运行时如果无法解析 `new Vue` 传入的 `template` ，则会走 `web-runtime` ；否则会执行 `web-full` （`web-runtime` + 模板解析）。

它调用了 `genConfig` 方法，该方法会去 `builds` 对象中找到对象打包目标对象中找到入口文件，部分源码如下：

```js
const builds = {
  // runtime-only build (Browser)
  'runtime-dev': {
    entry: resolve('web/entry-runtime.ts'),
    dest: resolve('dist/vue.runtime.js'),
    format: 'umd',
    env: 'development',
    banner
  },
  // Runtime+compiler development build (Browser)
  'full-dev': {
    entry: resolve('web/entry-runtime-with-compiler.ts'),
    dest: resolve('dist/vue.js'),
    format: 'umd',
    env: 'development',
    alias: { he: './entity-decoder' },
    banner
  },
}
```

其中 `entry` 是打包的文件文件路径，在 `web` 文件夹下的相应文件。但是 `scripts` 以及外部都没有这个 `web` 文件夹，因此还需要继续寻找。

调用了 `resolve` 函数，把路径传了过去，源码如下：

```js
const aliases = require('./alias')
const resolve = p => {
  const base = p.split('/')[0]
  if (aliases[base]) {
    return path.resolve(aliases[base], p.slice(base.length + 1))
  } else {
    return path.resolve(__dirname, '../', p)
  }
}
```

它拿到路径后和 `aliases` 做了拼接处理，因此根据路径查看 `aliases.js` 的代码，如下：

```js
module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  server: resolve('packages/server-renderer/src'),
  sfc: resolve('packages/compiler-sfc/src')
}
```

可以看到其 `web` 实际上是 `src/platforms/web` 路径，现在能够通过拼接，找到对应的打包文件的入口路径了。

查看源码，发现它们都使用了 `runtime` ：

```js
import Vue from './runtime/index'
```

而 `entry-runtime-with-compiler` 的区别是多实现了一个  `compile` API，把 `template` 转化成 `render` 函数。

下面先来看看这个 `compile` API 做了什么处理。源代码如下所示：

```js
// 函数劫持，将原来的mount函数获取到后重写mount函数
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  // 获取el元素
  el = el && query(el)

  /* istanbul ignore if */
  // 挂载的流程是用一个新生成的dom替换掉老的dom元素
  if (el === document.body || el === document.documentElement) {
    __DEV__ &&
      warn(
        `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
      )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) { // 如果有render函数则直接使用用户的render函数
    let template = options.template
    if (template) { // 如果没有render，查看是否有模板
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          // 考虑到 {template: '#template'} 的情况
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (__DEV__ && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        // 如果给的模板是一个dom元素，则拿到模板中的内容
        template = template.innerHTML
      } else {
        if (__DEV__) {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      // @ts-expect-error
      // 如果没有模板，则使用el对应的template
      template = getOuterHTML(el)
    }
    if (template) {
      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile')
      }

      // 直接将模板变成render函数
      const { render, staticRenderFns } = compileToFunctions(
        template,
        {
          outputSourceRange: __DEV__,
          shouldDecodeNewlines,
          shouldDecodeNewlinesForHref,
          delimiters: options.delimiters,
          comments: options.comments
        },
        this
      )
      options.render = render
      options.staticRenderFns = staticRenderFns

      /* istanbul ignore if */
      if (__DEV__ && config.performance && mark) {
        mark('compile end')
        measure(`vue ${this._name} compile`, 'compile', 'compile end')
      }
    }
  }
  // 调用了挂载
  return mount.call(this, el, hydrating)
}
```

查看其源码不难发现，他只做了一件事情，就是重写了 `$mount` 函数，将 `template` 变成 `render` 函数。这就是 `entry-runtime-width-compiler` 比 `entry-runtime` 命令多出来的区别。

接着我们再往上面看，看一下双方都有的 `runtime/index` 文件内的方法做了什么处理。它是运行时，所谓运行时，就是提供一些 DOM 操作的 API ，比如属性操作、元素操作等，还有一些指令和组件。

其中，部分源码如下所示：

```js
// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives) // 添加平台对应的指令和组件
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop // 渲染时会调用的方法，更新时会调用的方法。noop是一个空函数，如果在服务端渲染，则不需要调用方法，因此给一个空函数即可

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined

  // 组件的挂载
  return mountComponent(this, el, hydrating)
}
```

主要是为原型上安装一个 `__patch__` 的方法，判断当前的渲染环境是否在服务器端，如果在服务器端，则执行空函数 `noop` 。

在原型上挂载一个 `$mount` 函数，最终 `return` 导出一个组件的挂载的方法。

但是这还不是入口文件，往上滑发现它从 `core/index` 文件导入方法，因此前往查看它做了什么处理。

打开 `core/index.js` 文件，发现它依旧不是入口文件，做了一个导入导出。该文件增加了两个标识：是否是服务端渲染、服务端渲染的上下文，并且初始化 Vue 的全局 API 。部分源码如下：

```js
initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})
```

根据文件路径继续网上找，查看 `core/instance/index` 文件，发现他没有外部导入 Vue 方法，而是创建了一个 Vue 的构造函数。其源码如下所示：

```js
function Vue(options) {
  if (__DEV__ && !(this instanceof Vue)) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
```

可以看到其本质上在函数中调用了 `_init()` 初始化的方法，然后调用了几个函数，在 Vue 的原型 `prototype` 上挂载方法。作用分别是：

- `initMixin` ：挂载初始化方法 `_init` 
- `stateMixin` ：挂载 `$set` 、`$delete` 、`$watch` 方法
- `eventsMixin` ：挂载 `$on` 、`$off` 、`$emit` 方法
- `lifecycleMixin` ：挂载 `_update` 、`$forceUpdate` 强制刷新、`$destory` 销毁方法、
- `renderMixin` ：挂载 `$nextTick` 、`_render` 方法

总结出一句就是在扩展原型上的方法。

一图流如下所示：

![一图流](https://pic.imgdb.cn/item/652b962ac458853aef593e21.jpg)

> 里面每一个具体怎么实现？
>
> 1. 如果找了核心流程，可以单独打开源码查看
> 2. 如果不清楚流程，可以写一些测试用例和案例来调试。通过为编译命令行添加 `--sourcemap` 让编译后的源文件可以 `debuggr` 调试

### 全局API分析

看看它的全局 API 是怎么实现的。找到 `src/core/global-api/index.js` 文件，里面有一个 `initClobalAPI()` 函数。

首先它代理了 `config` 方法，用于配置信息，源码如下：

```js
const configDef: Record<string, any> = {}
configDef.get = () => config
if (__DEV__) {
  configDef.set = () => {
    warn(
      'Do not replace the Vue.config object, set individual fields instead.'
    )
  }
}
Object.defineProperty(Vue, 'config', configDef)
```

然后配置了 Vue 中的工具方法，如合并 `extend` 、合并策略 `mergeOptions` 、定义响应式 `defineReactive` 等。还有一些常用的方法，如 `set` 、`delete` 、`nextTick` 等。源码如下：

```js
Vue.util = {
  warn,
  extend,
  mergeOptions,
  defineReactive
}

Vue.set = set
Vue.delete = del
Vue.nextTick = nextTick
```

其中，关于 `nextTick` 可以查看我的博客文档 [nextTick](/learn/杂技拾谈/Vue/$nexttick) 。

再往下是让一个对象变成响应式的方法，源码如下：

```js
Vue.observable = <T>(obj: T): T => {
  observe(obj)
  return obj
}
```

最后在 Vue 方法上通过 `Object.create` 设置空对象 `options` ，并通过循环赋值空对象，并让 `_base` 一直指向 Vue 构造函数。

使用 `extend` 方法挂载 `keep-alive` 方法。

再从其他页面导入对应的方法注册，分别是：

- Vue.use
- Vue.mixin
- Vue.extend
- Vue.component、Vue.directive、Vue.filter

源码如下：

```js
Vue.options = Object.create(null)
ASSET_TYPES.forEach(type => {
  Vue.options[type + 's'] = Object.create(null)
})

// this is used to identify the "base" constructor to extend all plain-object
// components with in Weex's multi-instance scenarios.
Vue.options._base = Vue

extend(Vue.options.components, builtInComponents)

initUse(Vue)
initMixin(Vue)
initExtend(Vue)
initAssetRegisters(Vue)
```

### 响应式数组

1. 响应式数据的理解

   `initData` 函数中调用 `observe` 方法回调，对数据作监听。调用 `defineReactive` 方法劫持代理（内部重写了所有属性）。递归增加对象中的对象增加 `geter` 和 `setter` 。

   如果层级过深，则需要考虑优化（递归代理消耗性能）。如果数据不是响应式的就不要放在 `data` 中了。在取值的时候要避免多次取值，如果有些对象放到 `data` 内但不是响应式的，可以考虑 `Object.freeze()` 来冻结对象。

2. 检测数组变化

   Vue2 中检测数组变化没有采用 `defineProperty` ，因为修改索引的情况不多（如果直接采用 `defineProperty` 会浪费大量性能）。采用重写数组的变异方法来实现（函数劫持）。

   ```js
   if (isArray(value)) {
     // 如果是数组，则判断它有没有__proto__对应方法，如果有说明已经代理过了，没有则没代理过，通过拷贝为其赋值
     if (!mock) {
       if (hasProto) {
         ;(value as any).__proto__ = arrayMethods
       } else {
         for (let i = 0, l = arrayKeys.length; i < l; i++) {
           const key = arrayKeys[i]
           def(value, key, arrayMethods[key])
         }
       }
     }
     if (!shallow) {
       this.observeArray(value)
     }
   } else {
     const keys = Object.keys(value)
     for (let i = 0; i < keys.length; i++) {
       const key = keys[i]
       defineReactive(value, key, NO_INITIAL_VALUE, undefined, shallow, mock)
     }
   }
   ```

   通过阅读源码可以看出其步骤顺序如下：调用 `initData` 函数，调用 `observe` 回调，对传入的数组进行原型链修改，后续调用的方法都是重写后的方法，对数组中每个对象也再次代理。

### 依赖收集

所谓的依赖收集，实际上是观察者模式。被观察者指代的是数据（即观察数据的变化）；观察者是 `watcher` ，里面可能有渲染逻辑、计算属性、用户 `watcher` 。

观察者要观察数据，则需要通过 `dep` 先收集数据。一个 `watcher` 中需要先可能对应多个数据，`watcher` 中还需要保存 `dep` 。重写渲染的时候可以让属性重新记录 `watcher` 。

> `dep` 与 `watcher` 是多对多的关系，一个 `dep` 对应多个 `watcher` ，一个 `watcher` 内有多个 `dep` 。
>
> 默认渲染时会收集依赖，触发 `get` 方法。数据更新了就找到属性对应的 `watcher` 去触发更新。数据更新了就找到对应的 `watcher` 触发更新。
>
> 如果不触发 `$mount` ，就不会 `render` 更新，也就不会收集依赖。

一图流如下：

![一图流](https://pic.imgdb.cn/item/652ca4efc458853aef7d3cd2.jpg)

一个视图渲染的属性有可能不一样，因此每次都会先清理，然后重新收集依赖。如果不清理，改旧的、现在没用到的属性也会造成视图更新。每次重新渲染都会触发 `getter` 方法，在这个方法收集依赖。

### 模板编译

用户传递的是 `template` 属性，需要将这个 `template` 编译成 `render` 函数。

- 首先转换成 AST 语法树
- 对语法树进行标记（静态节点）
- AST语法树生成 `render` 函数

### 生命周期

在 `src/core/util/options.js` 文件中的 444 行开始，循环父亲和儿子的所有属性，然后调用 `mergeField` 函数做合并操作。源码如下：

```js
const options: ComponentOptions = {} as any
let key
// 循环父亲所有属性
for (key in parent) {
  mergeField(key)
}
// 循环儿子所有属性
for (key in child) {
  if (!hasOwn(parent, key)) {
    mergeField(key)
  }
}
// 策略模式
function mergeField(key: any) {
  const strat = strats[key] || defaultStrat
  options[key] = strat(parent[key], child[key], vm, key)
}
```

而策略模式中默认如果有儿子的属性方法则采用儿子的，没有才使用父亲的属性方法，源码如下：

```js
const defaultStrat = function (parentVal: any, childVal: any): any {
  // 以儿子为主
  return childVal === undefined ? parentVal : childVal
}
```

接下来看看 `strats` 的 `hook` 内封装了啥方法，源码如下：

```js
export function mergeLifecycleHook(
  parentVal: Array<Function> | null,
  childVal: Function | Array<Function> | null
): Array<Function> | null {
  // 获取父亲和儿子的
  const res = childVal
    ? parentVal
      ? parentVal.concat(childVal) // 都有就合并
      : isArray(childVal) // 否则看儿子是不是数组，是数组直接用，不是则用数组包裹
      ? childVal
      : [childVal]
    : parentVal
  return res ? dedupeHooks(res) : res
}
```

去到 `src/core/instance/lifecycle.js` 文件，找到生命周期的钩子回调函数，源码如下：

```js
export function callHook(
  vm: Component,
  hook: string,
  args?: any[],
  setContext = true
) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget()
  const prev = currentInstance
  setContext && setCurrentInstance(vm)
  const handlers = vm.$options[hook]
  const info = `${hook} hook`
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, args || null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
  setContext && setCurrentInstance(prev)
  popTarget()
}
```

实现原理是利用发布订阅模式，将用户写的钩子维护成一个数组，后续依次调用 `callHook` 。主要依靠的是 `mergeOptions` 方法。

> 为什么有些钩子是先子后父，有些是先父后子？
>
> 主要是看组件是如何渲染的。看下方代码：
>
> ```vue
> <div id="app">
>   <my-button></my-button>
> </div>
> ```
>
> 遇到父组件 `#app` ，开始渲染父组件，触发其 `beforeCreate` 钩子函数。然后遇到子组件 `my-button` ，开始渲染子组件，触发子组件的 `beforeCreate` 钩子函数。
>
> 渲染完毕后触发子组件的 `mounted` 钩子函数，继续往下，渲染父组件，渲染完毕后触发父组件的 `mounted` 。

#### 题外话

一般在哪里发送请求？

`beforeCreate` 生命周期的数据还未实现响应式，从源码下手证明这一点。

在 `src/core/instance/init.js` 文件的 59行左右，函数调用顺序如下：

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate', undefined, false /* setContext */)
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

首先调用 `initLifecycle` 函数，该方法源码如下：

```js
export function initLifecycle(vm: Component) {
  const options = vm.$options

  // locate first non-abstract parent
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }

  vm.$parent = parent
  vm.$root = parent ? parent.$root : vm

  vm.$children = []
  vm.$refs = {}

  vm._provided = parent ? parent._provided : Object.create(null)
  vm._watcher = null
  vm._inactive = null
  vm._directInactive = false
  vm._isMounted = false
  vm._isDestroyed = false
  vm._isBeingDestroyed = false
}
```

总结下来就是处理组件父子关系，如 `$parent` 、`$children` 等。

然后调用了 `initEvents` 方法函数，该方法主要初始化一些全局方法，如 `$on` 、`$off` 、`$emit` 等。源码如下所示：

```js
export function eventsMixin(Vue: typeof Component) {
  const hookRE = /^hook:/
  Vue.prototype.$on = function() {}
  Vue.prototype.$once = function() {}
  Vue.prototype.$off = function() {}
  Vue.prototype.$emit = function() {}
}
```

然后调用了 `beforeCreate` 生命周期钩子函数，该函数无法获取数据，作用不大，因此 Vue3 把它剔除了。

然后调用了 `initInjections` 方法，该方法主要是注册初始化 `resolve` 、`injections` 、`before` 、`data/props` 、`inject` 等方法。紧接着调用 `initState` 函数方法，此时劫持数据并做响应式处理。执行完毕后调用 `initProvide` 函数，主要实现 `provide` 方法。

再然后才调用 `created` 生命函数，此时拿到的是响应式的属性（不涉及 DOM 渲染），这个 API 可以在服务端渲染中使用。在 Vue3 中改为 `setup` 。

然后代码执行到 `src/core/instance/lifecycle.js` 文件中的 146 行，触发 `beforeMount` 生命周期回调。源码如下：

```js
  vm.$el = el
  if (!vm.$options.render) {
    // @ts-expect-error invalid type
    vm.$options.render = createEmptyVNode
    if (__DEV__) {
      /* istanbul ignore if */
      if (
        (vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el ||
        el
      ) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
            'compiler is not available. Either pre-compile the templates into ' +
            'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }
  callHook(vm, 'beforeMount')
```

该方法的意义不大，逻辑可以写到 `create` 钩子函数内，获取 DOM 元素并操作的方法可以写到 `mounted` 钩子函数内。

等到 DOM 元素渲染完毕，判断通过，才调用 `mounted` 回调函数。源码如下：

```js
if (vm.$vnode == null) {
  vm._isMounted = true
  callHook(vm, 'mounted')
}
```

当有数据更新时，就会重新渲染，此时会被 `Watcher` 监听到，调用 `beforeUpdate` 钩子函数。源码如下：

```js
const watcherOptions: WatcherOptions = {
  before() {
    if (vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate')
    }
  }
}
```

执行 `watcher.before()` 方法调用更新，源码如下：

```js
watcher = queue[index]
if (watcher.before) {
  watcher.before()
}
id = watcher.id
has[id] = null
watcher.run()
```

组件更新完毕后调用 `updated` 钩子函数，源码如下：

```js
function callUpdatedHooks(queue: Watcher[]) {
  let i = queue.length
  while (i--) {
    const watcher = queue[i]
    const vm = watcher.vm
    if (vm && vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated')
    }
  }
}
```

如果销毁组件，最好在 `beforeDestory` 钩子函数上移除定时器等，此时数据还是响应式的。清理完之后调用 `destoryed` 钩子函数，此时数据没有响应式了，但是真实 DOM 还在。源码如下：

```js
Vue.prototype.$destroy = function () {
  const vm: Component = this
  if (vm._isBeingDestroyed) {
    return
  }
  // 调用销毁前
  callHook(vm, 'beforeDestroy')
  vm._isBeingDestroyed = true
  // 移除 $children
  const parent = vm.$parent
  if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
    remove(parent.$children, vm)
  }
  vm._scope.stop()
  // 清除数据的响应式
  if (vm._data.__ob__) {
    vm._data.__ob__.vmCount--
  }
  vm._isDestroyed = true
  // 把最新的虚拟节点标记为null
  vm.__patch__(vm._vnode, null)
  callHook(vm, 'destroyed')
  // 关闭所有事件
  vm.$off()
  if (vm.$el) {
    vm.$el.__vue__ = null
  }
  if (vm.$vnode) {
    vm.$vnode.parent = null
  }
}
```

从上所述，一般最多在 `mounted` 上发请求。代码是同步执行的，请求是异步的，都会等待 `mounted` 之后才获取数据，因此不差 `created` 那点时间。

服务端渲染不都是在 `created` 中（服务端没有 DOM，也没有 `mounted` 钩子）。在哪发请求主要看需要做什么操作。

### mixin原理及作用

通过 `Vue.mixin` 实现逻辑的复用，代码如下：

```js
const request = () => {}

Vue.mixin({
    beforeCreate() {
        this.$request = request()
    },
    beforeDestory() {
        // ...
    }
})

new Vue({
    el: '#app',
    components: {
        my: {
            template: '<button @click="handle"></button>',
            methods: {
                handle() {
                    console.log(this.$request)
                }
            }
        }
    }
})
```

虽然实现了复用，但还是有一点问题：

1. 数据来源不明确。全局 `mixin` 每个组件都可调用，项目大时后续的维护会比较诧异变量的来源
2. 声明的时候可能会导致命名冲突

在 Vue3 中，采用高阶组件的形式，规避这一缺点。

从源码入手分析，在 `src/core/global-api/mixin.js` 文件内，源码如下所示：

```js
export function initMixin(Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
```

这里的 `this` 是谁调用就指向谁，由于该 `mixin` 方法是 Vue 调用的，因此 `this` 实际上是 Vue。最终将 `mixin` 对象和 `Vue.options` 合并在一起。

查看 `mergeOptions` 函数的源码，如下所示：

```js
export function mergeOptions(
  parent: Record<string, any>,
  child: Record<string, any>,
  vm?: Component | null
): ComponentOptions {
  if (__DEV__) {
    checkComponents(child)
  }

  // 合并的是一个组件的构造函数
  if (isFunction(child)) {
    child = child.options
  }

  normalizeProps(child, vm)
  normalizeInject(child, vm)
  normalizeDirectives(child)

  if (!child._base) {
    // 针对组件的 extends 属性来进行合并
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm)
    }
    // 针对组件内部的 mixins 来进行合并，即组件通过 mixins: [xxx] 来注册局部 mixin
    if (child.mixins) {
      for (let i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm)
      }
    }
  }

  const options: ComponentOptions = {} as any
  let key
  for (key in parent) {
    mergeField(key)
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key)
    }
  }
  function mergeField(key: any) {
    const strat = strats[key] || defaultStrat
    options[key] = strat(parent[key], child[key], vm, key)
  }
  return options
}
```

总结下来，`mixin` 核心就是合并属性（内部采用策略模式进行合并），全局 `mixin` 与局部 `mixin` 针对不同的属性有不同的合并策略。

### data为什么是函数



### nextTick实现原理

`nextTick` 内部采用了异步任务进行包装（多个 `nextTick` 调用会被合并成一次，内部会合并回调）。最后在异步任务中批次处理。

主要应用场景就是异步更新（默认调度的时候，就会添加一个 `nextTick` 任务）用户为了获取最终的渲染结果需要在内部任务执行之后再执行，这时用户需要把对应的逻辑放到 `nextTick` 中。

每次触发更新都会执行 `Watcher` 类的 `update` 方法，源码如下：

```js
update() {
  if (this.lazy) {
    this.dirty = true
  } else if (this.sync) {
    this.run()
  } else {
    queueWatcher(this)
  }
}
```

而方法 `queueWatcher` 则负责过滤同名 `watcher` ，并将多个渲染 `watcher` 去重后放到队列中。源码如下：

```js
export function queueWatcher(watcher: Watcher) {
  // 负责过滤同名 `watcher`
  const id = watcher.id
  if (has[id] != null) {
    return
  }

  if (watcher === Dep.target && watcher.noRecurse) {
    return
  }

  has[id] = true
  if (!flushing) {
    // 多个渲染 `watcher` 去重后放到队列
    queue.push(watcher)
  } else {
    let i = queue.length - 1
    while (i > index && queue[i].id > watcher.id) {
      i--
    }
    queue.splice(i + 1, 0, watcher)
  }
  if (!waiting) {
    waiting = true

    if (__DEV__ && !config.async) {
      flushSchedulerQueue()
      return
    }
    nextTick(flushSchedulerQueue)
  }
}
```

前往文件 `src/core/util/next-tick.js` 文件中，找到 `necttick` 函数，源码如下：

```js
export function nextTick(cb?: (...args: any[]) => any, ctx?: object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e: any) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(resolve => {
      _resolve = resolve
    })
  }
}
```

它还对当前浏览器能否使用 `Promise` 做了判断，如果可以使用则为微任务，不可使用则改为宏任务。源码如下：

```js
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  const p = Promise.resolve()
  timerFunc = () => {
    p.then(flushCallbacks)
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) setTimeout(noop)
  }
  isUsingMicroTask = true
} else if (
  !isIE &&
  typeof MutationObserver !== 'undefined' &&
  (isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]')
) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  let counter = 1
  const observer = new MutationObserver(flushCallbacks)
  const textNode = document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: true
  })
  timerFunc = () => {
    counter = (counter + 1) % 2
    textNode.data = String(counter)
  }
  isUsingMicroTask = true
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Technically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = () => {
    setImmediate(flushCallbacks)
  }
} else {
  // Fallback to setTimeout.
  timerFunc = () => {
    setTimeout(flushCallbacks, 0)
  }
}
```

了解完源码后下方这道题就浅显易懂了，先看代码：

```js
const vm = new Vue({
    data() {
        return {
            a: 1
        }
    }
})

vm.$nextTick(() => {
    console.log(vm.a)
})

vm.a = 100

vm.$nextTick(() => {
    console.log(vm.a)
})
```

根据源码可知，他会开辟一个数组队列，一次把任务推送到数组队列中。首先推送第一次的 `nextTick` ，然后推送更新操作，最后推送第二次的 `nextTick` 。

因此先打印1，然后修改值为100，再打印100。

### watch与computed原理

### set的实现

### 虚拟DOM的意义

### diff算法

### key的原理和作用

### 组件化特点