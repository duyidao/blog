# 消除异步传染性

下面来看一段代码：

```js
async function getUser() {
  return await fetch('http://xxx/demo/profile')
  	.then(res => res.json());
}

async function m1() {
  return await getUser();
}

async function m2() {
  return await m1();
}

async function m3() {
  return await m2();
}

async function main() {
  const user = await m3();
  console.log(user)
}
```

有一个函数 `getUser` ，调用接口获取数据，通过 `async` 和 `await` 获取异步数据，此时该函数添加了 `async` 后会变为 `Promise` 异步函数。后续函数想要使用该函数也需要再一次 `async` 和 `await` ，如上方代码所示。

这样虽说能够解决，但是代码看起来冗杂，且让函数从纯函数变成了异步函数，带来了副作用。如何把那些函数都变成同步函数，且最终能够打印出结果？

首先需要定位最主要的问题在哪里。毋庸置疑，在最开始的 `getUser` 函数，因为需要获取到数据，因此才开始一系列的 `async` 和 `await` 。因此需要在这里做文章。

在取消掉 `async` 和 `await` 后函数如下：

```js
async function getUser() {
  return await fetch('http://xxx/demo/profile')
  	.then(res => res.json());
}
```

此时需要它立即返回结果，但是由于接口请求还没回来，它无法返回响应的数据，那么怎么解决呢？报错，对的没错，这里既然无法返回接口响应的数据，那么就返回一个报错信息过去。

这个思路可以用一个图来解释，如下图所示：

![思路](https://pic.imgdb.cn/item/65b4c667871b83018a6595b0.jpg)