import{_ as s,c as i,o as a,U as n}from"./chunks/framework.pP-Hyzfo.js";const o=JSON.parse('{"title":"优化","description":"","frontmatter":{},"headers":[],"relativePath":"project/baidu/layer/优化.md","filePath":"project/baidu/layer/优化.md","lastUpdated":1706340641000}'),h={name:"project/baidu/layer/优化.md"},p=n(`<h1 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h1><p>在项目中，优化也是一个不可或缺的环节，在业务中，我涉及到的优化有以下几点：</p><ul><li>代码优化：通过引入第三方库或方法实现同样的功能，代码量更少，易读性更好</li><li>性能优化：通过引入第三方库等方法实现地图渲染加载速度优化</li></ul><p>关于优化，在项目中我涉及到的分别有以下几点。</p><h2 id="数据抽稀" tabindex="-1">数据抽稀 <a class="header-anchor" href="#数据抽稀" aria-label="Permalink to &quot;数据抽稀&quot;">​</a></h2><p>有一个图层需求是渲染地图面，UI效果如下所示：</p><p><img src="https://pic.imgdb.cn/item/65a77030871b83018ac8379b.jpg" alt="效果"></p><p>根据地图官网可以使用 <code>Polygon</code> 方法渲染面。不过由于后端返回的数据量过于庞大，因此在渲染的时候耗时很长，长达半分钟左右才能加载完毕。</p><p>这显然是不合理的，因此需要做点优化。在搜索时，发现有一个集成库 <code>Turf.js</code> 用于处理地图数据，其中它有一个 <code>simplify</code> 方法可以简化数据。官网指路：<a href="https://turfjs.fenxianglu.cn/category/transformation/simplify.html" target="_blank" rel="noreferrer">简化多边形 | Turf.js中文网 (fenxianglu.cn)</a> 。</p><p>根据官方文档指示，需要先使用库的 <code>polygon</code> 方法获取需要的数据。该方法传入一个首尾相同数据的三维数组。然后设置抽稀程度、是否允许修改等参数。最后调用 <code>simplify</code> 方法获取到抽稀后的简化版本。</p><p>抽稀函数封装如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 抽稀</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lessDataFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> arr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 首尾相同</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> option</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {tolerance: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.009</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, highQuality: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mutate: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> newArr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果当前数据长度大于4，则抽稀</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (p.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arrHandle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> simplify</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">polygon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([p]), option);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrHandle.geometry.coordinates[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newArr;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="接口请求次数" tabindex="-1">接口请求次数 <a class="header-anchor" href="#接口请求次数" aria-label="Permalink to &quot;接口请求次数&quot;">​</a></h2><p>由于数据量过于庞大，后端接口请求速度也会有所变慢，如果网络环境稍差，还会请求失败。此处也可以做一个缓存优化。</p><p>一般情况下提到缓存，都会想到浏览器缓存 <code>localStorage</code> ，不过数据量庞大浏览器缓存也未必能够存的下，因此这里可以通过 <code>new Map</code> 缓存到内存中。</p><p>如果 <code>new Map().has()</code> 能够拿到数据，说明之前已经调用过接口获取数据并保存，此时直接获取数据即可，不再需要调接口；反之才需要调用接口获取数据并保存。</p><p>代码如下所示：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> polygonDataMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setArea</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> async</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> payload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (polygonDataMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload.areaName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;-search&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        xxx.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> polygonDataMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload.areaName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;-search&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> yyy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    districtPolygonList.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    polygonDataMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(payload.areaName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;-search&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, districtPolygonList.value);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><p>保存后运行，可以发现后续页面渲染速度变快很多。</p><h2 id="细粒度追踪响应式数据变化" tabindex="-1">细粒度追踪响应式数据变化 <a class="header-anchor" href="#细粒度追踪响应式数据变化" aria-label="Permalink to &quot;细粒度追踪响应式数据变化&quot;">​</a></h2><p>地图产生的相关元素变量，在保存成响应式时，不使用 <code>ref</code> 保存，而是用 <code>shallowRef</code> 。</p><p>在 Vue 3 中，shallowRef 替换掉 ref 的优化是对响应式数据进行更加细粒度的追踪，从而提高性能的优化。</p><p>在 Vue 2 中，ref 的实现方式是双向绑定，即当数据变化时，会触发更新视图的操作。然而，这种实现方式有一个缺点：它会追踪整个对象或数组的变化，即使只有其中一个属性发生了变化，也会重新渲染整个对象或数组。这样就会导致性能问题，特别是在处理大型对象或数组时。</p><p>Vue 3 中引入了 shallowRef，它通过使用 Proxy 对象来实现，可以进行比较精细的响应式追踪。与 ref 不同的是，shallowRef 只会追踪对象或数组的第一层属性，当第一层属性发生变化时，才会触发更新视图的操作。这样就可以避免不必要的重新渲染，提高性能。</p><p>适用场景：</p><ul><li>当需要追踪一个简单对象或数组的变化时，可以使用 shallowRef。</li><li>当需要追踪一个复杂对象或数组的变化时，可以使用 reactive 或 ref 来实现深层次的响应式追踪。</li></ul>`,26),l=[p];function t(k,e,r,d,E,g){return a(),i("div",null,l)}const c=s(h,[["render",t]]);export{o as __pageData,c as default};
