import{_ as s,o as a,c as p,Q as n}from"./chunks/framework.2ee92742.js";const h=JSON.parse('{"title":"运用前瞻实现密码强度检测","description":"","frontmatter":{},"headers":[],"relativePath":"learn/Reg/do/运用前瞻实现密码强度检测.md","filePath":"learn/Reg/do/运用前瞻实现密码强度检测.md","lastUpdated":null}'),l={name:"learn/Reg/do/运用前瞻实现密码强度检测.md"},o=n(`<h1 id="运用前瞻实现密码强度检测" tabindex="-1">运用前瞻实现密码强度检测 <a class="header-anchor" href="#运用前瞻实现密码强度检测" aria-label="Permalink to &quot;运用前瞻实现密码强度检测&quot;">​</a></h1><p>有一个要求，需要设置一个正则检测密码强度，要求有两点：</p><ol><li>密码 6-12 位</li><li>必须包含数字、大小写字母、特殊字符</li></ol><p>咋一看很简单，直接用 <code>[]</code> 包含以及 <code>{6,12}</code> 设置长度即可，代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">^</span><span style="color:#79B8FF;">[0-9a-zA-Z@!$_]</span><span style="color:#F97583;">{6,12}$</span><span style="color:#9ECBFF;">/</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">/</span><span style="color:#D73A49;">^</span><span style="color:#005CC5;">[0-9a-zA-Z@!$_]</span><span style="color:#D73A49;">{6,12}$</span><span style="color:#032F62;">/</span></span></code></pre></div><p>但是这并不是正确的写法，如果这么写，全是数字的密码也能通过校验。因为上方规则表示任选其一。</p><p>想要实现要求，需要使用到前瞻运算。正则匹配实际上是规则和字符串一起移动来匹配，如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">^</span><span style="color:#DBEDFF;">abc</span><span style="color:#F97583;">$</span><span style="color:#9ECBFF;">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">abc</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">/</span><span style="color:#D73A49;">^</span><span style="color:#032F62;">abc</span><span style="color:#D73A49;">$</span><span style="color:#032F62;">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">abc</span></span></code></pre></div><p>首先匹配正则的开始标识 <code>^</code> ，字符串的匹配指针为字母 <code>a</code> 前面；然后正则往后一位匹配到 <code>a</code> ，字符串匹配指针也往后一位到字母 <code>a</code> ；正则往后一位到 <code>b</code> ，字符串匹配指针也往后一位到字母 <code>b</code> ......直到最后匹配完毕。</p><p>但如果把匹配规则改一下，使用前瞻（也就是正向预查）就无法匹配了。代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">^</span><span style="color:#DBEDFF;">(?=a)bc</span><span style="color:#F97583;">$</span><span style="color:#9ECBFF;">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">abc</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">/</span><span style="color:#D73A49;">^</span><span style="color:#032F62;">(?=a)bc</span><span style="color:#D73A49;">$</span><span style="color:#032F62;">/</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">abc</span></span></code></pre></div><p>正则匹配到前瞻时不会消耗字符，首先匹配正则的开始标识 <code>^</code> ，字符串的匹配指针为字母 <code>a</code> 前面；然后正则往后一位匹配到前瞻 <code>(?=a)</code> ，而字符串的匹配指针不会跟着往后移动。因此匹配不成功。</p><p>那他有什么好处呢？可以在匹配的时候先不着急消耗字符串往后匹配，而是先往后看看是否满足规则。用上方的要求来说，利用前瞻不消耗的特性在最开始看后续有没有大小写字母、数字、特殊字符。</p><p>修改后写法如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#9ECBFF;">/</span><span style="color:#F97583;">^</span><span style="color:#DBEDFF;">(?=</span><span style="color:#79B8FF;">.</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">[0-9]</span><span style="color:#DBEDFF;">)(?=</span><span style="color:#79B8FF;">.</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">[a-z]</span><span style="color:#DBEDFF;">)(?=</span><span style="color:#79B8FF;">.</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">[A-Z]</span><span style="color:#DBEDFF;">)(?=</span><span style="color:#79B8FF;">.</span><span style="color:#F97583;">*</span><span style="color:#79B8FF;">[@!$_]</span><span style="color:#DBEDFF;">)]</span><span style="color:#F97583;">{6,12}$</span><span style="color:#9ECBFF;">/</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#032F62;">/</span><span style="color:#D73A49;">^</span><span style="color:#032F62;">(?=</span><span style="color:#005CC5;">.</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">[0-9]</span><span style="color:#032F62;">)(?=</span><span style="color:#005CC5;">.</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">[a-z]</span><span style="color:#032F62;">)(?=</span><span style="color:#005CC5;">.</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">[A-Z]</span><span style="color:#032F62;">)(?=</span><span style="color:#005CC5;">.</span><span style="color:#D73A49;">*</span><span style="color:#005CC5;">[@!$_]</span><span style="color:#032F62;">)]</span><span style="color:#D73A49;">{6,12}$</span><span style="color:#032F62;">/</span></span></code></pre></div><p>现在就能够实现密码强度检测了。</p>`,16),e=[o];function c(t,r,d,i,y,F){return a(),p("div",null,e)}const C=s(l,[["render",c]]);export{h as __pageData,C as default};
