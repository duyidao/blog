import{_ as s,o as e,c as o,Q as a}from"./chunks/framework.2ee92742.js";const g=JSON.parse('{"title":"windoe.onstorage标签页通信","description":"","frontmatter":{},"headers":[],"relativePath":"learn/杂技拾谈/JS/windoe.onstorage标签页通信.md","filePath":"learn/杂技拾谈/JS/windoe.onstorage标签页通信.md","lastUpdated":null}'),n={name:"learn/杂技拾谈/JS/windoe.onstorage标签页通信.md"},l=a(`<h1 id="windoe-onstorage标签页通信" tabindex="-1">windoe.onstorage标签页通信 <a class="header-anchor" href="#windoe-onstorage标签页通信" aria-label="Permalink to &quot;windoe.onstorage标签页通信&quot;">​</a></h1><p>标签页通信的常见方案有如下几点：</p><ul><li>BroadCast Channel</li><li>Service Worker</li><li>LocalStorage 通过 windoe.onstorage 监听</li><li>Shared Worker 定时器轮询（setInterval）</li><li>IndexedDB 定时器轮询（setInterval）</li><li>cookie定时器轮询（setInterval）</li><li>window.open、window.postMessage</li><li>Websocket</li></ul><p>这里重点放在如何使用 <code>windoe.onstorage()</code> 本地存储监听实现标签页通信。全局对象 <code>window</code> 有一个事件 <code>storage</code> ，代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">window.</span><span style="color:#B392F0;">addEventListener</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;storage&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">e</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(e)</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">window.</span><span style="color:#6F42C1;">addEventListener</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;storage&#39;</span><span style="color:#24292E;">, (</span><span style="color:#E36209;">e</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(e)</span></span>
<span class="line"><span style="color:#24292E;">})</span></span></code></pre></div><p>该方法在其他标签页改变了本地存储的内容后触发，其形参可以获取到一个对象，其中包含了以下有用的信息：</p><ul><li>变化的键名 key</li><li>变化后的新值 newValue</li><li>变化前的旧值 oldValue</li></ul><p>封装两个函数</p>`,8),t=[l];function p(r,c,i,d,E,_){return e(),o("div",null,t)}const w=s(n,[["render",p]]);export{g as __pageData,w as default};
